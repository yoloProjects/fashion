{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { LRNGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function lRNGrad(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var x = inputs.x,\n      y = inputs.y,\n      dy = inputs.dy;\n  var depthRadius = attrs.depthRadius,\n      bias = attrs.bias,\n      alpha = attrs.alpha,\n      beta = attrs.beta;\n  assertNotComplex(dy, 'LRNGrad');\n  var dySize = util.sizeFromShape(dy.shape);\n  var channels = dy.shape[3];\n  var dyValues = backend.data.get(dy.dataId).values;\n  var xValues = backend.data.get(x.dataId).values;\n  var yValues = backend.data.get(y.dataId).values;\n  var result = new Float32Array(dySize);\n  var size = dySize;\n\n  for (var offset = 0; offset < size; offset++) {\n    var currentChannel = offset % channels;\n    var depthBegin = offset - currentChannel + Math.max(0, currentChannel - depthRadius);\n    var depthEnd = offset - currentChannel + Math.min(channels, currentChannel + depthRadius + 1);\n    var norm = 0;\n\n    for (var k = depthBegin; k < depthEnd; k++) {\n      norm += Math.pow(xValues[k], 2);\n    }\n\n    norm = alpha * norm + bias;\n\n    for (var _k = depthBegin; _k < depthEnd; _k++) {\n      var dyi = -2 * alpha * beta * xValues[_k] * yValues[offset] / norm;\n\n      if (offset === _k) {\n        dyi += Math.pow(norm, -beta);\n      }\n\n      dyi *= dyValues[offset];\n      result[_k] += dyi;\n    }\n  }\n\n  return backend.makeTensorInfo(dy.shape, x.dtype, result);\n}\nexport var lRNGradConfig = {\n  kernelName: LRNGrad,\n  backendName: 'cpu',\n  kernelFunc: lRNGrad\n};","map":null,"metadata":{},"sourceType":"module"}