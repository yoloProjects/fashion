{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function sparseReshapeImpl(inputIndices, inputIndicesShape, inputDType, inputShape, targetShape) {\n  var denseSize = util.sizeFromShape(inputShape);\n  var nnz = inputIndicesShape[0];\n  var outputRank = targetShape.length; // Compute the output shape. Determine product of specified dimensions, and\n  // find the index of the unspecified one.\n\n  var outputShape = [];\n  var product = 1;\n  var unknownIndex = -1;\n\n  for (var d = 0; d < outputRank; ++d) {\n    var size = targetShape[d];\n\n    if (size === -1) {\n      if (unknownIndex !== -1) {\n        throw new Error(\"only one output dimension may be -1, not both \".concat(unknownIndex, \" and \").concat(d));\n      }\n\n      unknownIndex = d;\n      outputShape.push(1);\n    } else {\n      if (size < 0) {\n        throw new Error(\"size \".concat(d, \" must be non-negative, not \").concat(size));\n      }\n\n      product *= size;\n      outputShape.push(size);\n    }\n  }\n\n  if (unknownIndex !== -1) {\n    if (product <= 0) {\n      throw new Error('reshape cannot infer the missing ' + 'input size for an empty tensor unless all ' + 'specified input sizes are non-zero');\n    }\n\n    var missing = Math.trunc(denseSize / product);\n\n    if (product * missing !== denseSize) {\n      throw new Error(\"Input to reshape is a SparseTensor with \".concat(denseSize, \"\\n          dense values, but the requested shape requires a multiple of \").concat(product, \". inputShape=\").concat(inputShape, \" outputShape= \").concat(outputShape));\n    }\n\n    outputShape[unknownIndex] = missing;\n  }\n\n  var outputSize = util.sizeFromShape(outputShape);\n\n  if (outputSize !== denseSize) {\n    throw new Error(\"Input to reshape is a tensor with \".concat(denseSize, \" dense values, but the requested shape has \").concat(outputSize, \". inputShape=\").concat(inputShape, \" outputShape=\").concat(outputShape));\n  }\n\n  var inputRank = inputShape.length;\n  var inputStrides = [];\n\n  if (inputRank > 0) {\n    inputStrides[inputRank - 1] = 1;\n\n    for (var _d = inputRank - 2; _d >= 0; --_d) {\n      inputStrides[_d] = inputStrides[_d + 1] * inputShape[_d + 1];\n    }\n  }\n\n  var outputStrides = [];\n\n  if (outputRank > 0) {\n    outputStrides[outputRank - 1] = 1;\n\n    for (var _d2 = outputRank - 2; _d2 >= 0; --_d2) {\n      outputStrides[_d2] = outputStrides[_d2 + 1] * outputShape[_d2 + 1];\n    }\n  }\n\n  var newIndices = util.getArrayFromDType(inputDType, nnz * outputRank);\n\n  for (var i = 0; i < nnz; ++i) {\n    var id = 0;\n\n    for (var j = 0; j < inputRank; ++j) {\n      // inputIndices is a 2d tensor with shape of [nnz, inputRank]\n      id += inputIndices[i * inputRank + j] * inputStrides[j];\n    }\n\n    for (var _j = 0; _j < outputRank; ++_j) {\n      // newIndices is a 2d tensor with shape of [nnz, outputRank]\n      newIndices[i * outputRank + _j] = Math.trunc(id / outputStrides[_j]);\n      id %= outputStrides[_j];\n    }\n  }\n\n  return [newIndices, [nnz, outputRank], outputShape];\n}","map":null,"metadata":{},"sourceType":"module"}