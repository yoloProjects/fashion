{"ast":null,"code":"import _slicedToArray from \"C:\\\\PythonProjects\\\\Fashion\\\\YOLOTFjf\\\\tfjs-yolov5-example\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeBilinear, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeBilinear(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var images = inputs.images;\n  var alignCorners = attrs.alignCorners,\n      halfPixelCenters = attrs.halfPixelCenters,\n      size = attrs.size;\n  assertNotComplex(images, 'resizeBilinear');\n  var imagesStrides = util.computeStrides(images.shape);\n\n  var _size = _slicedToArray(size, 2),\n      newHeight = _size[0],\n      newWidth = _size[1];\n\n  var _images$shape = _slicedToArray(images.shape, 4),\n      batch = _images$shape[0],\n      oldHeight = _images$shape[1],\n      oldWidth = _images$shape[2],\n      numChannels = _images$shape[3];\n\n  var xValues = backend.data.get(images.dataId).values;\n  var result = new Float32Array(util.sizeFromShape([batch, newHeight, newWidth, numChannels]));\n  var effectiveInputSize = [alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight, alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth];\n  var effectiveOutputSize = [alignCorners && newHeight > 1 ? newHeight - 1 : newHeight, alignCorners && newWidth > 1 ? newWidth - 1 : newWidth];\n  var outputIdx = 0;\n  var effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];\n  var effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];\n\n  for (var b = 0; b < batch; b++) {\n    for (var r = 0; r < newHeight; r++) {\n      var sourceFracRow = void 0;\n\n      if (halfPixelCenters) {\n        sourceFracRow = effectiveRowSizeRatio * (r + 0.5) - 0.5;\n      } else {\n        sourceFracRow = effectiveRowSizeRatio * r;\n      }\n\n      var sourceRowFloor = Math.max(0, Math.floor(sourceFracRow));\n      var rowFrac = sourceFracRow - sourceRowFloor;\n      var sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));\n      var topRowOffset = b * imagesStrides[0] + sourceRowFloor * imagesStrides[1];\n      var botRowOffset = b * imagesStrides[0] + sourceRowCeil * imagesStrides[1];\n\n      for (var c = 0; c < newWidth; c++) {\n        var sourceFracCol = void 0;\n\n        if (halfPixelCenters) {\n          sourceFracCol = effectiveColSizeRatio * (c + 0.5) - 0.5;\n        } else {\n          sourceFracCol = effectiveColSizeRatio * c;\n        }\n\n        var sourceColFloor = Math.max(0, Math.floor(sourceFracCol));\n        var colFrac = sourceFracCol - sourceColFloor;\n        var sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));\n        var topLeftOffest = topRowOffset + sourceColFloor * imagesStrides[2];\n        var botLeftOffset = botRowOffset + sourceColFloor * imagesStrides[2];\n        var topRightOffset = topRowOffset + sourceColCeil * imagesStrides[2];\n        var botRightOffest = botRowOffset + sourceColCeil * imagesStrides[2];\n\n        for (var d = 0; d < numChannels; d++) {\n          // Begin shader.\n          // Compute the fractional index of the source.\n          var topLeft = xValues[topLeftOffest + d];\n          var bottomLeft = xValues[botLeftOffset + d];\n          var topRight = xValues[topRightOffset + d];\n          var bottomRight = xValues[botRightOffest + d];\n          var top = topLeft + (topRight - topLeft) * colFrac;\n          var bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;\n          var newValue = top + (bottom - top) * rowFrac;\n          result[outputIdx++] = newValue;\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo([batch, newHeight, newWidth, numChannels], 'float32', result);\n}\nexport var resizeBilinearConfig = {\n  kernelName: ResizeBilinear,\n  backendName: 'cpu',\n  kernelFunc: resizeBilinear\n};","map":null,"metadata":{},"sourceType":"module"}