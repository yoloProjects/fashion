{"ast":null,"code":"import _slicedToArray from \"C:\\\\PythonProjects\\\\For GIt\\\\FashionDetect\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeNearestNeighborGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeNearestNeighborGrad(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var images = inputs.images,\n      dy = inputs.dy;\n  var alignCorners = attrs.alignCorners;\n  assertNotComplex([dy, images], 'resizeNearestNeighborGrad');\n  var imagesStrides = util.computeStrides(images.shape);\n  var dyStrides = util.computeStrides(dy.shape);\n\n  var _images$shape = _slicedToArray(images.shape, 4),\n      batch = _images$shape[0],\n      xHeight = _images$shape[1],\n      xWidth = _images$shape[2],\n      depth = _images$shape[3];\n\n  var _dy$shape = _slicedToArray(dy.shape, 3),\n      yHeight = _dy$shape[1],\n      yWidth = _dy$shape[2];\n\n  var output = new Float32Array(batch * xHeight * xWidth * depth);\n  var dyValues = backend.data.get(dy.dataId).values; // In the backwards pass, we want to find the pixels that were generated\n  // for each pixel in the input image the forward pass\n\n  var effectiveXSize = [alignCorners && yHeight > 1 ? xHeight - 1 : xHeight, alignCorners && yWidth > 1 ? xWidth - 1 : xWidth];\n  var effectiveYSize = [alignCorners && yHeight > 1 ? yHeight - 1 : yHeight, alignCorners && yWidth > 1 ? yWidth - 1 : yWidth];\n  var heightScale = effectiveXSize[0] / effectiveYSize[0];\n  var widthScale = effectiveXSize[1] / effectiveYSize[1];\n  var invHeightScale = 1 / heightScale;\n  var invWidthScale = 1 / widthScale; // This defines the size of the window of values around a particular\n  // index in dy that we want to search for contributions to dx.\n\n  var winHeight = Math.ceil(invHeightScale) * 2 + 2;\n  var winWidth = Math.ceil(invWidthScale) * 2 + 2; // Loop over the output space.\n\n  for (var b = 0; b < batch; b++) {\n    var batchOffset = b * imagesStrides[0];\n\n    for (var r = 0; r < xHeight; r++) {\n      var rowOffset = batchOffset + r * imagesStrides[1]; // Compute bounds for where in dy we will look\n\n      var startRLerp = Math.floor(r * invHeightScale);\n      var startDyR = Math.floor(startRLerp - winHeight / 2);\n\n      for (var c = 0; c < xWidth; c++) {\n        var colOffset = rowOffset + c * imagesStrides[2]; // Compute bounds for where in dy we will look\n\n        var startCLerp = Math.floor(c * invWidthScale);\n        var startDyC = Math.floor(startCLerp - winWidth / 2);\n\n        for (var d = 0; d < depth; d++) {\n          var accum = 0; // loop over dy\n\n          for (var dyRIndex = 0; dyRIndex < winHeight; dyRIndex++) {\n            var dyR = dyRIndex + startDyR; // Guard against the window exceeding the bounds of dy\n\n            if (dyR < 0 || dyR >= yHeight) {\n              continue;\n            }\n\n            var dyROffset = batchOffset + dyR * dyStrides[1];\n            var sourceFracRow = dyR * heightScale;\n            var sourceNearestRow = Math.min(xHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));\n\n            if (r !== sourceNearestRow) {\n              continue;\n            }\n\n            for (var dyCIndex = 0; dyCIndex < winWidth; dyCIndex++) {\n              var dyC = dyCIndex + startDyC; // Guard against the window exceeding the bounds of dy\n\n              if (dyC < 0 || dyC >= yWidth) {\n                continue;\n              }\n\n              var dyCOffset = dyROffset + dyC * dyStrides[2];\n              var sourceFracCol = dyC * widthScale;\n              var sourceNearestCol = Math.min(xWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));\n\n              if (c === sourceNearestCol) {\n                accum += dyValues[dyCOffset + d];\n              }\n            }\n          }\n\n          output[colOffset + d] = accum;\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo(images.shape, images.dtype, output);\n}\nexport var resizeNearestNeighborGradConfig = {\n  kernelName: ResizeNearestNeighborGrad,\n  backendName: 'cpu',\n  kernelFunc: resizeNearestNeighborGrad\n};","map":null,"metadata":{},"sourceType":"module"}