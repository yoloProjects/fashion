{"ast":null,"code":"import _slicedToArray from \"C:\\\\PythonProjects\\\\For GIt\\\\FashionDetect\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, TopK, util } from '@tensorflow/tfjs-core';\nimport { topKImplCPU } from '../kernel_utils/shared';\nimport { MergeProgram, SwapProgram } from '../top_k_gpu';\nimport { fill } from './Fill';\nimport { gatherV2 } from './GatherV2';\nimport { reshape } from './Reshape';\nimport { slice } from './Slice';\n\nfunction disposeIntermediateTensorInfoOrNull(backend, tensorInfo) {\n  if (tensorInfo !== null) {\n    backend.disposeIntermediateTensorInfo(tensorInfo);\n  }\n}\n\nfunction roundUpToPow2(num) {\n  var pow2 = 1;\n\n  while (pow2 < num) {\n    pow2 *= 2;\n  }\n\n  return pow2;\n} // Based on Algorithm 2 of Bitonic Top K, ref:\n// https://anilshanbhag.in/static/papers/gputopk_sigmod18.pdf\n\n\nexport function topK(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var x = inputs.x;\n  var k = attrs.k,\n      sorted = attrs.sorted; // Empirically determined constant used to determine last dim threshold for\n  // handing off execution to the CPU.\n\n  var TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber('TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD'); // Empirically determined constant used to determine k threshold for handing\n  // off execution to the CPU.\n\n  var TOPK_K_CPU_HANDOFF_THRESHOLD = env().getNumber('TOPK_K_CPU_HANDOFF_THRESHOLD');\n  var xShape = x.shape;\n  var lastDim = xShape[xShape.length - 1];\n\n  if (backend.shouldExecuteOnCPU([x]) || lastDim < TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD || k > TOPK_K_CPU_HANDOFF_THRESHOLD) {\n    var xVals = backend.readSync(x.dataId);\n\n    var _topKImplCPU = topKImplCPU(xVals, xShape, x.dtype, k, sorted),\n        _topKImplCPU2 = _slicedToArray(_topKImplCPU, 2),\n        allTopKVals = _topKImplCPU2[0],\n        allTopKIndices = _topKImplCPU2[1];\n\n    return [backend.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values), backend.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)];\n  }\n\n  if (k === 0) {\n    xShape[xShape.length - 1] = 0;\n    return [backend.makeTensorInfo(xShape, x.dtype, []), backend.makeTensorInfo(xShape, 'int32', [])];\n  }\n\n  if (lastDim === 1\n  /* firstPass */\n  ) {\n    return [x, fill({\n      attrs: {\n        shape: xShape,\n        dtype: 'int32',\n        value: 0\n      },\n      backend: backend\n    })];\n  } // Eagerly unpack x input since it is passed in to all the shaders which\n  // require unpacked inputs.\n\n\n  var xtexData = backend.texData.get(x.dataId);\n  var xIsPacked = xtexData !== null && xtexData.isPacked;\n  var xUnPacked = xIsPacked ? backend.unpackTensor(x) : x; // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.\n\n  var xSize = util.sizeFromShape(xShape);\n  var batch = xSize / lastDim;\n  var x2D = reshape({\n    inputs: {\n      x: xUnPacked\n    },\n    attrs: {\n      shape: [batch, lastDim]\n    },\n    backend: backend\n  });\n\n  if (xIsPacked) {\n    disposeIntermediateTensorInfoOrNull(backend, xUnPacked);\n  }\n\n  var kPow2 = roundUpToPow2(k);\n  var lastDimPow2 = roundUpToPow2(lastDim); // Only the indices containing the top K are kept at every step to reduce\n  // number of outputs in the GPU algorithms, so once the final set of indices\n  // is computed then gather is used to grab the corresponding values\n  // from the original input.\n\n  var indices = null; // GPU algorithm always takes in an indices input but this input is not used\n  // on the first run of a GPU algorithm, therefore if indices is null we simply\n  // pass in x2D instead of it but the value will not actually be used\n\n  var getInputs = function getInputs() {\n    return indices === null ? [x2D, x2D] : [x2D, indices];\n  };\n\n  var runSwap = function runSwap(dir, inc, shape) {\n    var inputs = getInputs();\n    var program = new SwapProgram(shape);\n    var fistPass = indices === null ? 1 : 0;\n    var customValues = [[lastDim], [fistPass], [Number.NEGATIVE_INFINITY], [dir], [inc]];\n    var prevIndices = indices;\n    indices = backend.runWebGLProgram(program, inputs, 'int32', customValues);\n    disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n  }; // Step 1: local sort\n\n\n  for (var len = 1; len < kPow2; len *= 2) {\n    var dir = len * 2;\n\n    for (var inc = len; inc >= 1; inc /= 2) {\n      runSwap(dir, inc, [batch, lastDimPow2]);\n    }\n  } // Step 2: merge\n\n\n  for (var indicesSize = lastDimPow2; indicesSize > kPow2; indicesSize /= 2) {\n    var _inputs = getInputs();\n\n    var mergeProgram = new MergeProgram([batch, indicesSize / 2]);\n    var firstPass = indices === null ? 1 : 0;\n    var customValues = [[lastDim], [firstPass], [kPow2]];\n    var _prevIndices = indices;\n    indices = backend.runWebGLProgram(mergeProgram, _inputs, 'int32', customValues);\n    disposeIntermediateTensorInfoOrNull(backend, _prevIndices); // Step 3: rebuild\n\n    var _len = kPow2 / 2;\n\n    var _dir = _len * 2;\n\n    for (var _inc = _len; _inc >= 1; _inc /= 2) {\n      runSwap(_dir, _inc, indices.shape);\n    }\n  } // Keep only the requested top K results instead of kPow2\n\n\n  var prevIndices = indices;\n  indices = slice({\n    inputs: {\n      x: indices\n    },\n    backend: backend,\n    attrs: {\n      begin: 0,\n      size: [batch, k]\n    }\n  });\n  disposeIntermediateTensorInfoOrNull(backend, prevIndices); // Gather values on last dimension\n\n  var values = gatherV2({\n    inputs: {\n      x: x2D,\n      indices: indices\n    },\n    backend: backend,\n    attrs: {\n      axis: 1,\n      batchDims: 1\n    }\n  });\n  disposeIntermediateTensorInfoOrNull(backend, x2D); // Reshape back to the original input shape, except that the last\n  // dimension is k.\n\n  var newShape = xShape.slice(0, -1);\n  newShape.push(k);\n  prevIndices = indices;\n  indices = reshape({\n    inputs: {\n      x: indices\n    },\n    attrs: {\n      shape: newShape\n    },\n    backend: backend\n  });\n  disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n  var prevValues = values;\n  values = reshape({\n    inputs: {\n      x: values\n    },\n    attrs: {\n      shape: newShape\n    },\n    backend: backend\n  });\n  disposeIntermediateTensorInfoOrNull(backend, prevValues);\n  return [values, indices];\n}\nexport var topKConfig = {\n  kernelName: TopK,\n  backendName: 'webgl',\n  kernelFunc: topK\n};","map":null,"metadata":{},"sourceType":"module"}