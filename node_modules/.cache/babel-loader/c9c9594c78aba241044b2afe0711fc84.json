{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function sparseSegmentReductionImpl(input, inputShape, inputDType, indices, segmentIds) {\n  var isMean = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var defaultValue = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var numIndices = indices.length;\n\n  if (numIndices !== segmentIds.length) {\n    throw new Error(\"segmentIds and indices should have same size.\");\n  } // Flatten the array to two dimensions\n\n\n  var inputFlat = [inputShape[0], input.length / inputShape[0]];\n  var numCol = inputFlat[1]; // Note that the current implementation assumes that segmentIds values are\n  // sorted.\n\n  var lastSegmentIdPlusOne = numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;\n  var outputRows = lastSegmentIdPlusOne;\n\n  if (outputRows < 0) {\n    throw new Error(\"segment ids must be >= 0\");\n  }\n\n  var outputShape = inputShape.slice();\n  outputShape[0] = outputRows;\n  var outputLength = outputShape.reduce(function (product, value) {\n    return product * value;\n  }, 1); // Output array is initialized with the value 0 by default.\n\n  var output = util.getArrayFromDType(inputDType, outputLength); // Note that we do not initialize the output buffer with a default value, so\n  // we need to explicitly set missing indices to the default value.\n\n  if (numIndices === 0) {\n    if (outputRows > 0) {\n      output.fill(defaultValue);\n    }\n\n    return [output, outputShape];\n  }\n\n  if (outputRows <= 0) {\n    throw new Error(\"segment ids must be >= 0\");\n  }\n\n  var start = 0,\n      end = 1; // Index from which the output is not initialized.\n\n  var uninitializedIndex = 0;\n  var outIndex = segmentIds[start];\n\n  while (true) {\n    // We initialize nextIndex to 0 to avoid may be uninitialized warning\n    var nextIndex = 0;\n\n    if (end < numIndices) {\n      nextIndex = segmentIds[end];\n\n      if (outIndex === nextIndex) {\n        ++end;\n        continue;\n      } // We have a new segment here.  Verify that the segment ids are growing.\n\n\n      if (outIndex >= nextIndex) {\n        throw new Error(\"segment ids are not increasing\");\n      }\n    }\n\n    if (outIndex < 0 || outIndex >= outputRows) {\n      throw new Error(\"Segment id \".concat(outIndex, \" out of range [0, \").concat(outputRows, \"), possibly because segmentIds input is not sorted.\"));\n    } // If there is a gap between two indices, we need to set that gap to the\n    // default value.\n\n\n    if (outIndex > uninitializedIndex) {\n      output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);\n    }\n\n    for (var i = start; i < end; ++i) {\n      var index = indices[i];\n\n      if (index < 0 || index >= inputFlat[0]) {\n        throw new Error(\"Bad: indices[\".concat(i, \"] == \").concat(indices[i], \" out of range [0, \").concat(inputFlat[0], \")\"));\n      }\n\n      for (var j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] += input[index * numCol + j];\n      }\n    }\n\n    if (isMean) {\n      for (var _j = 0; _j < numCol; _j++) {\n        output[outIndex * numCol + _j] /= end - start;\n      }\n    }\n\n    start = end;\n    ++end;\n    uninitializedIndex = outIndex + 1;\n    outIndex = nextIndex;\n\n    if (end > numIndices) {\n      break;\n    }\n  } // Fill the gap at the end with the default value.\n\n\n  if (uninitializedIndex < outputRows) {\n    output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);\n  }\n\n  return [output, outputShape];\n}","map":null,"metadata":{},"sourceType":"module"}