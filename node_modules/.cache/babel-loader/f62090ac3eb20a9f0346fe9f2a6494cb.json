{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Workaround for allowing cjs module to be included in bundle created by\n// rollup.\nimport * as LongExports from 'long'; // tslint:disable-next-line\n\nvar Long = // tslint:disable-next-line\nLongExports.default || LongExports;\nexport function hexToLong(hex) {\n  return Long.fromString(hex, true, 16);\n} // Some primes between 2^63 and 2^64 for various uses.\n// Hex 0xc3a5c85c97cb3127\n\nvar k0 = hexToLong('c3a5c85c97cb3127'); // Hex 0xb492b66fbe98f273\n\nvar k1 = hexToLong('b492b66fbe98f273'); // Hex 0x9ae16a3b2f90404f\n\nvar k2 = hexToLong('9ae16a3b2f90404f');\n\nfunction shiftMix(val) {\n  return val.xor(val.shru(47));\n}\n\nfunction fetch(s, offset, numBytes) {\n  var bytes = s.slice(offset, offset + numBytes);\n  return Long.fromBytes(Array.from(bytes), true, true);\n}\n\nfunction fetch64(s, offset) {\n  return fetch(s, offset, 8);\n}\n\nfunction fetch32(s, offset) {\n  return fetch(s, offset, 4);\n}\n\nfunction rotate64(val, shift) {\n  // Avoid shifting by 64: doing so yields an undefined result.\n  return shift === 0 ? val : val.shru(shift).or(val.shl(64 - shift));\n}\n\nfunction hashLen16(u, v) {\n  var mul = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : hexToLong('9ddfea08eb382d69');\n  // Murmur-inspired hashing.\n  var a = u.xor(v).mul(mul);\n  a = a.xor(a.shru(47));\n  var b = v.xor(a).mul(mul);\n  b = b.xor(b.shru(47));\n  b = b.mul(mul);\n  return b;\n} // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n// Callers do best to use \"random-looking\" values for a and b.\n\n\nfunction weakHashLen32WithSeeds(w, x, y, z, a, b) {\n  a = a.add(w);\n  b = rotate64(b.add(a).add(z), 21);\n  var c = a;\n  a = a.add(x);\n  a = a.add(y);\n  b = b.add(rotate64(a, 44));\n  return [a.add(z), b.add(c)];\n}\n\nfunction weakHashLen32WithSeedsStr(s, offset, a, b) {\n  return weakHashLen32WithSeeds(fetch64(s, offset), fetch64(s, offset + 8), fetch64(s, offset + 16), fetch64(s, offset + 24), a, b);\n}\n\nfunction hashLen0to16(s) {\n  var len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : s.length;\n\n  if (len >= 8) {\n    var mul = k2.add(len * 2);\n    var a = fetch64(s, 0).add(k2);\n    var b = fetch64(s, len - 8);\n    var c = rotate64(b, 37).mul(mul).add(a);\n    var d = rotate64(a, 25).add(b).mul(mul);\n    return hashLen16(c, d, mul);\n  }\n\n  if (len >= 4) {\n    var _mul = k2.add(len * 2);\n\n    var _a = fetch32(s, 0);\n\n    return hashLen16(_a.shl(3).add(len), fetch32(s, len - 4), _mul);\n  }\n\n  if (len > 0) {\n    var _a2 = s[0];\n    var _b = s[len >> 1];\n    var _c = s[len - 1];\n    var y = _a2 + (_b << 8);\n    var z = len + (_c << 2);\n    return shiftMix(k2.mul(y).xor(k0.mul(z))).mul(k2);\n  }\n\n  return k2;\n}\n\nfunction hashLen17to32(s) {\n  var len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : s.length;\n  var mul = k2.add(len * 2);\n  var a = fetch64(s, 0).mul(k1);\n  var b = fetch64(s, 8);\n  var c = fetch64(s, len - 8).mul(mul);\n  var d = fetch64(s, len - 16).mul(k2);\n  return hashLen16(rotate64(a.add(b), 43).add(rotate64(c, 30)).add(d), a.add(rotate64(b.add(k2), 18)).add(c), mul);\n}\n\nfunction hashLen33to64(s) {\n  var len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : s.length;\n  var mul = k2.add(len * 2);\n  var a = fetch64(s, 0).mul(k2);\n  var b = fetch64(s, 8);\n  var c = fetch64(s, len - 8).mul(mul);\n  var d = fetch64(s, len - 16).mul(k2);\n  var y = rotate64(a.add(b), 43).add(rotate64(c, 30)).add(d);\n  var z = hashLen16(y, a.add(rotate64(b.add(k2), 18)).add(c), mul);\n  var e = fetch64(s, 16).mul(mul);\n  var f = fetch64(s, 24);\n  var g = y.add(fetch64(s, len - 32)).mul(mul);\n  var h = z.add(fetch64(s, len - 24)).mul(mul);\n  return hashLen16(rotate64(e.add(f), 43).add(rotate64(g, 30)).add(h), e.add(rotate64(f.add(a), 18)).add(g), mul);\n}\n\nexport function fingerPrint64(s) {\n  var len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : s.length;\n  var seed = Long.fromNumber(81, true);\n\n  if (len <= 32) {\n    if (len <= 16) {\n      return hashLen0to16(s, len);\n    } else {\n      return hashLen17to32(s, len);\n    }\n  } else if (len <= 64) {\n    return hashLen33to64(s, len);\n  } // For strings over 64 bytes we loop.  Internal state consists of\n  // 56 bytes: v, w, x, y, and z.\n\n\n  var x = seed;\n  var y = seed.mul(k1).add(113);\n  var z = shiftMix(y.mul(k2).add(113)).mul(k2);\n  var v = [Long.UZERO, Long.UZERO];\n  var w = [Long.UZERO, Long.UZERO];\n  x = x.mul(k2).add(fetch64(s, 0));\n  var offset = 0; // Set end so that after the loop we have 1 to 64 bytes left to process.\n\n  var end = (len - 1 >> 6) * 64;\n  var last64 = end + (len - 1 & 63) - 63;\n\n  do {\n    x = rotate64(x.add(y).add(v[0]).add(fetch64(s, offset + 8)), 37).mul(k1);\n    y = rotate64(y.add(v[1]).add(fetch64(s, offset + 48)), 42).mul(k1);\n    x = x.xor(w[1]);\n    y = y.add(v[0]).add(fetch64(s, offset + 40));\n    z = rotate64(z.add(w[0]), 33).mul(k1);\n    v = weakHashLen32WithSeedsStr(s, offset, v[1].mul(k1), x.add(w[0]));\n    w = weakHashLen32WithSeedsStr(s, offset + 32, z.add(w[1]), y.add(fetch64(s, offset + 16)));\n    var _ref = [x, z];\n    z = _ref[0];\n    x = _ref[1];\n    offset += 64;\n  } while (offset !== end);\n\n  var mul = k1.add(z.and(0xff).shl(1)); // Point to the last 64 bytes of input.\n\n  offset = last64;\n  w[0] = w[0].add(len - 1 & 63);\n  v[0] = v[0].add(w[0]);\n  w[0] = w[0].add(v[0]);\n  x = rotate64(x.add(y).add(v[0]).add(fetch64(s, offset + 8)), 37).mul(mul);\n  y = rotate64(y.add(v[1]).add(fetch64(s, offset + 48)), 42).mul(mul);\n  x = x.xor(w[1].mul(9));\n  y = y.add(v[0].mul(9).add(fetch64(s, offset + 40)));\n  z = rotate64(z.add(w[0]), 33).mul(mul);\n  v = weakHashLen32WithSeedsStr(s, offset, v[1].mul(mul), x.add(w[0]));\n  w = weakHashLen32WithSeedsStr(s, offset + 32, z.add(w[1]), y.add(fetch64(s, offset + 16)));\n  z = x;\n  x = z;\n  return hashLen16(hashLen16(v[0], w[0], mul).add(shiftMix(y).mul(k0)).add(z), hashLen16(v[1], w[1], mul).add(x), mul);\n}","map":null,"metadata":{},"sourceType":"module"}