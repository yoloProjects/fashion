{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nexport function concatImpl(inputs, outShape, dtype, simplyConcat) {\n  var outVals = util.getArrayFromDType(dtype, util.sizeFromShape(outShape));\n\n  if (simplyConcat && dtype !== 'string') {\n    // Use built-in TypedArray.set() method for speed.\n    var offset = 0;\n    inputs.forEach(function (input) {\n      var size = util.sizeFromShape(input.shape);\n      outVals.set(input.vals, offset);\n      offset += size;\n    });\n  } else {\n    var colOffset = 0;\n    inputs.forEach(function (input) {\n      var decodedData = dtype === 'string' ? backend_util.fromUint8ToStringArray(input.vals) : input.vals;\n      var tIdx = 0;\n\n      for (var row = 0; row < input.shape[0]; ++row) {\n        var resIdx = row * outShape[1] + colOffset;\n\n        for (var col = 0; col < input.shape[1]; ++col) {\n          outVals[resIdx + col] = decodedData[tIdx++];\n        }\n      }\n\n      colOffset += input.shape[1];\n    });\n  }\n\n  return outVals;\n}","map":null,"metadata":{},"sourceType":"module"}