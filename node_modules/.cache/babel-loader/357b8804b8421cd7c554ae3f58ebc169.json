{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, env, util } from '@tensorflow/tfjs-core';\nimport * as shader_compiler from './shader_compiler';\nexport function compileProgram(gpgpu, program, inputs, output) {\n  var inputInfos = inputs.map(function (input, i) {\n    var shapeInfo = {\n      logicalShape: input.shape,\n      texShape: input.isUniform ? null : input.texData.texShape,\n      isUniform: input.isUniform,\n      isPacked: input.isUniform ? false : input.texData.isPacked,\n      flatOffset: null\n    };\n\n    if (input.texData != null && input.texData.slice != null && input.texData.slice.flatOffset > 0) {\n      shapeInfo.flatOffset = input.texData.slice.flatOffset;\n    }\n\n    return {\n      name: program.variableNames[i],\n      shapeInfo: shapeInfo\n    };\n  });\n  var inShapeInfos = inputInfos.map(function (x) {\n    return x.shapeInfo;\n  });\n  var outShapeInfo = {\n    logicalShape: output.shape,\n    texShape: output.texData.texShape,\n    isUniform: false,\n    isPacked: output.texData.isPacked,\n    flatOffset: null\n  };\n  var source = shader_compiler.makeShader(inputInfos, outShapeInfo, program);\n  var webGLProgram = gpgpu.createProgram(source); // Add special uniforms (NAN, INFINITY)\n\n  var infLoc = null;\n  var nanLoc = gpgpu.getUniformLocation(webGLProgram, 'NAN', false);\n\n  if (env().getNumber('WEBGL_VERSION') === 1) {\n    infLoc = gpgpu.getUniformLocation(webGLProgram, 'INFINITY', false);\n  } // Add user-defined uniforms\n\n\n  var shouldThrow = false;\n  var uniformLocations = {};\n  var inShapesLocations = {};\n  var inTexShapesLocations = {};\n\n  for (var i = 0; i < program.variableNames.length; i++) {\n    var varName = program.variableNames[i];\n    uniformLocations[varName] = gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);\n    uniformLocations[\"offset\".concat(varName)] = gpgpu.getUniformLocation(webGLProgram, \"offset\".concat(varName), shouldThrow);\n\n    if (program.enableShapeUniforms) {\n      inShapesLocations[\"\".concat(varName, \"Shape\")] = gpgpu.getUniformLocation(webGLProgram, \"\".concat(varName, \"Shape\"), shouldThrow);\n      inTexShapesLocations[\"\".concat(varName, \"TexShape\")] = gpgpu.getUniformLocation(webGLProgram, \"\".concat(varName, \"TexShape\"), shouldThrow);\n    }\n  }\n\n  var outShapeLocation;\n  var outTexShapeLocation;\n  var outShapeStridesLocation;\n\n  if (program.enableShapeUniforms) {\n    outShapeLocation = gpgpu.getUniformLocation(webGLProgram, 'outShape', shouldThrow);\n    outShapeStridesLocation = gpgpu.getUniformLocation(webGLProgram, 'outShapeStrides', shouldThrow);\n    outTexShapeLocation = gpgpu.getUniformLocation(webGLProgram, 'outTexShape', shouldThrow);\n  }\n\n  var customUniformLocations = [];\n\n  if (program.customUniforms) {\n    program.customUniforms.forEach(function (d, i) {\n      customUniformLocations[i] = gpgpu.getUniformLocation(webGLProgram, d.name, shouldThrow);\n    });\n  }\n\n  return {\n    program: program,\n    source: source,\n    webGLProgram: webGLProgram,\n    uniformLocations: uniformLocations,\n    customUniformLocations: customUniformLocations,\n    inShapeInfos: inShapeInfos,\n    outShapeInfo: outShapeInfo,\n    infLoc: infLoc,\n    nanLoc: nanLoc,\n    inShapesLocations: inShapesLocations,\n    inTexShapesLocations: inTexShapesLocations,\n    outShapeLocation: outShapeLocation,\n    outShapeStridesLocation: outShapeStridesLocation,\n    outTexShapeLocation: outTexShapeLocation\n  };\n}\n\nfunction validateBinaryAndProgram(shapeInfos, inputs) {\n  if (shapeInfos.length !== inputs.length) {\n    throw Error(\"Binary was compiled with \".concat(shapeInfos.length, \" inputs, but \") + \"was executed with \".concat(inputs.length, \" inputs\"));\n  }\n\n  shapeInfos.forEach(function (s, i) {\n    var shapeA = s.logicalShape;\n    var input = inputs[i];\n    var shapeB = input.shape;\n\n    if (!util.arraysEqual(shapeA, shapeB)) {\n      throw Error(\"Binary was compiled with different shapes than \" + \"the current args. Shapes \".concat(shapeA, \" and \").concat(shapeB, \" must match\"));\n    } // The input is uploaded as uniform.\n\n\n    if (s.isUniform && input.isUniform) {\n      return;\n    }\n\n    var texShapeA = s.texShape;\n    var texShapeB = input.isUniform ? null : input.texData.texShape;\n\n    if (!util.arraysEqual(texShapeA, texShapeB)) {\n      throw Error(\"Binary was compiled with different texture shapes than the\" + \" current args. Shape \".concat(texShapeA, \" and \").concat(texShapeB, \" must match\"));\n    }\n  });\n}\n\nexport function runProgram(gpgpu, binary, inputs, output, customUniformValues) {\n  if (!binary.program.enableShapeUniforms) {\n    validateBinaryAndProgram(binary.inShapeInfos, inputs);\n    validateBinaryAndProgram([binary.outShapeInfo], [output]);\n  }\n\n  var outTex = output.texData.texture;\n  var outTexShape = output.texData.texShape;\n\n  if (output.texData.isPacked) {\n    gpgpu.setOutputPackedMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n  } else {\n    gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n  }\n\n  gpgpu.setProgram(binary.webGLProgram); // Set special uniforms (NAN, INFINITY)\n\n  if (env().getNumber('WEBGL_VERSION') === 1) {\n    if (binary.infLoc !== null) {\n      gpgpu.gl.uniform1f(binary.infLoc, Infinity);\n    }\n  }\n\n  if (binary.nanLoc !== null) {\n    gpgpu.gl.uniform1f(binary.nanLoc, NaN);\n  } // Set user-defined inputs\n\n\n  inputs.forEach(function (input, i) {\n    var varName = binary.program.variableNames[i];\n    var varLoc = binary.uniformLocations[varName];\n    var varOffsetLoc = binary.uniformLocations[\"offset\".concat(varName)];\n    var varShapeLoc = binary.inShapesLocations[\"\".concat(varName, \"Shape\")];\n    var varTexShapeLoc = binary.inTexShapesLocations[\"\".concat(varName, \"TexShape\")];\n\n    if (varShapeLoc) {\n      var _shader_compiler$getU = shader_compiler.getUniformInfoFromShape(binary.program.packedInputs, input.shape, input.texData.texShape),\n          uniformShape = _shader_compiler$getU.uniformShape;\n\n      switch (uniformShape.length) {\n        case 1:\n          gpgpu.gl.uniform1iv(varShapeLoc, new Int32Array(uniformShape));\n          break;\n\n        case 2:\n          gpgpu.gl.uniform2iv(varShapeLoc, new Int32Array(uniformShape));\n          break;\n\n        case 3:\n          gpgpu.gl.uniform3iv(varShapeLoc, new Int32Array(uniformShape));\n          break;\n\n        case 4:\n          gpgpu.gl.uniform4iv(varShapeLoc, new Int32Array(uniformShape));\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    if (varTexShapeLoc) {\n      gpgpu.gl.uniform2i(varTexShapeLoc, input.texData.texShape[0], input.texData.texShape[1]);\n    }\n\n    if (varLoc == null) {\n      // The compiler inferred that this variable is not used in this shader.\n      return;\n    }\n\n    if (input.isUniform) {\n      // Upload the values of the tensor as uniform.\n      if (util.sizeFromShape(input.shape) < 2) {\n        gpgpu.gl.uniform1f(varLoc, input.uniformValues[0]);\n      } else {\n        var vals = input.uniformValues;\n\n        if (!(vals instanceof Float32Array)) {\n          vals = new Float32Array(vals);\n        }\n\n        gpgpu.gl.uniform1fv(varLoc, vals);\n      }\n\n      return;\n    } // If the input was sliced, upload the flat offset index.\n\n\n    if (input.texData.slice != null && varOffsetLoc != null) {\n      gpgpu.gl.uniform1i(varOffsetLoc, input.texData.slice.flatOffset);\n    }\n\n    gpgpu.setInputMatrixTexture(input.texData.texture, varLoc, i);\n  });\n  var outShapeLoc = binary.outShapeLocation;\n\n  if (outShapeLoc) {\n    switch (output.shape.length) {\n      case 1:\n        gpgpu.gl.uniform1iv(outShapeLoc, new Int32Array(output.shape));\n        break;\n\n      case 2:\n        gpgpu.gl.uniform2iv(outShapeLoc, new Int32Array(output.shape));\n        break;\n\n      case 3:\n        gpgpu.gl.uniform3iv(outShapeLoc, new Int32Array(output.shape));\n        break;\n\n      case 4:\n        gpgpu.gl.uniform4iv(outShapeLoc, new Int32Array(output.shape));\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  if (binary.outShapeStridesLocation) {\n    var strides = util.computeStrides(output.shape);\n\n    switch (output.shape.length) {\n      case 2:\n        gpgpu.gl.uniform1iv(binary.outShapeStridesLocation, new Int32Array(strides));\n        break;\n\n      case 3:\n        gpgpu.gl.uniform2iv(binary.outShapeStridesLocation, new Int32Array(strides));\n        break;\n\n      case 4:\n        gpgpu.gl.uniform3iv(binary.outShapeStridesLocation, new Int32Array(strides));\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  if (binary.outTexShapeLocation) {\n    gpgpu.gl.uniform2i(binary.outTexShapeLocation, output.texData.texShape[0], output.texData.texShape[1]);\n  }\n\n  if (binary.program.customUniforms && customUniformValues) {\n    binary.program.customUniforms.forEach(function (d, i) {\n      var customLoc = binary.customUniformLocations[i];\n      var customValue = customUniformValues[i];\n\n      if (d.type === 'float') {\n        gpgpu.gl.uniform1fv(customLoc, customValue);\n      } else if (d.type === 'vec2') {\n        gpgpu.gl.uniform2fv(customLoc, customValue);\n      } else if (d.type === 'vec3') {\n        gpgpu.gl.uniform3fv(customLoc, customValue);\n      } else if (d.type === 'vec4') {\n        gpgpu.gl.uniform4fv(customLoc, customValue);\n      } else if (d.type === 'int') {\n        gpgpu.gl.uniform1iv(customLoc, customValue);\n      } else if (d.type === 'ivec2') {\n        gpgpu.gl.uniform2iv(customLoc, customValue);\n      } else if (d.type === 'ivec3') {\n        gpgpu.gl.uniform3iv(customLoc, customValue);\n      } else if (d.type === 'ivec4') {\n        gpgpu.gl.uniform4iv(customLoc, customValue);\n      } else {\n        throw Error(\"uniform type \".concat(d.type, \" is not supported yet.\"));\n      }\n    });\n  }\n\n  gpgpu.executeProgram();\n}\nexport function makeShaderKey(program, inputs, output) {\n  var keyInputs = '';\n  inputs.concat(output).forEach(function (x) {\n    var hasOffset = x.texData != null && x.texData.slice != null && x.texData.slice.flatOffset > 0; // TODO: Remove the condition of !x.isUniform.\n\n    if (program.enableShapeUniforms && !x.isUniform) {\n      var xTexShape = x.texData.texShape;\n\n      var _shader_compiler$getU2 = shader_compiler.getUniformInfoFromShape(program.packedInputs, x.shape, xTexShape),\n          useSqueezeShape = _shader_compiler$getU2.useSqueezeShape,\n          uniformShape = _shader_compiler$getU2.uniformShape,\n          keptDims = _shader_compiler$getU2.keptDims;\n\n      var rank1 = '',\n          rank2 = '',\n          rank34 = '';\n\n      if (uniformShape.length === 1 && program.packedInputs) {\n        var packedTexShape = [Math.ceil(xTexShape[0] / 2), Math.ceil(xTexShape[1] / 2)];\n        rank1 = \"\".concat(packedTexShape[0] > 1, \"_\").concat(packedTexShape[1] > 1);\n      } else if (uniformShape.length === 2 && !program.packedInputs) {\n        rank2 = \"\".concat(uniformShape[0] > 1, \"_\").concat(uniformShape[1] > 1);\n      } else if (uniformShape.length > 2 && !program.packedInputs) {\n        var strides = util.computeStrides(uniformShape);\n        rank34 = \"\".concat(strides[0] === xTexShape[1], \"_\").concat(strides[strides.length - 1] === xTexShape[1]);\n      }\n\n      var xRank = x.shape.length;\n      var isLogicalShapTexShapeEqual = uniformShape.length === 2 && util.arraysEqual(x.shape, xTexShape);\n      var isScalar = util.sizeFromShape(x.shape) === 1;\n      var broadcastDims = backend_util.getBroadcastDims(x.shape, output.shape);\n      var isInOutTexShapeEqual = !program.packedInputs && xRank === output.shape.length && util.arraysEqual(xTexShape, output.texData.texShape);\n      var isTexShapeGreaterThanOne = program.packedInputs || uniformShape.length > 2 ? '' : \"\".concat(xTexShape[0] > 1, \"_\").concat(xTexShape[1] > 1); // These key components are needed due to shader_compiler is embedding\n      // them in the shader.\n      // |xRank| is used to determine the coords length. See\n      // get[Packed]SamplerAtOutputCoords.\n      // |isInOutTexShapeEqual| is used to determine whether going to an\n      // optimization path in getSamplerAtOutputCoords.\n      // |useSqueezeShape| is extracted from squeezeInputInfo of\n      // getSampler[2|3|4]D/getPackedSampler3D.\n      // |isScalar| is extracted from isInputScalar/isOutputScalar in\n      // getPackedSamplerAtOutputCoords.\n      // |broadcastDims| is extracted from get[Packed]SamplerAtOutputCoords.\n      // |isLogicalShapTexShapeEqual| is used in\n      // getOutput[Packed]2DCoords/get[Packed]Sampler2D.\n      // |rank1| is used in getOutputPacked1DCoords.\n      // |rank2| is used in getOutput2DCoords.\n      // |rank34| is used in getSampler3D/getSampler4D.\n      // |isTexShapeGreaterThanOne| are used in\n      // getSampler[Scalar|1D|2D]/getOutput1DCoords.\n\n      keyInputs += \"\".concat(xRank, \"_\").concat(isInOutTexShapeEqual, \"_\").concat(useSqueezeShape ? keptDims : '', \"_\").concat(uniformShape.length, \"_\").concat(isScalar, \"_\").concat(broadcastDims, \"_\").concat(isLogicalShapTexShapeEqual, \"_\").concat(rank1, \"_\").concat(rank2, \"_\").concat(rank34, \"_\").concat(isTexShapeGreaterThanOne, \"_\").concat(hasOffset);\n    } else {\n      var texShape = x.isUniform ? 'uniform' : x.texData.texShape;\n      keyInputs += \"\".concat(x.shape, \"_\").concat(texShape, \"_\").concat(hasOffset);\n    }\n  });\n  var keyUserCode = program.userCode;\n  var key = program.constructor.name; // Fast string concat. See https://jsperf.com/string-concatenation/14.\n\n  key += '_' + keyInputs + '_' + keyUserCode + \"\".concat(env().getNumber('WEBGL_VERSION'));\n  return key;\n}\nexport function useShapeUniforms(rank) {\n  // TODO: Remove the limitaion of rank <= 4.\n  return env().getBool('WEBGL_USE_SHAPES_UNIFORMS') && rank <= 4;\n}","map":null,"metadata":{},"sourceType":"module"}