{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n\n/**\n * Math utility functions.\n *\n * This file contains some frequently used math function that operates on\n * number[] or Float32Array and return a number. Many of these functions are\n * not-so-thick wrappers around TF.js Core functions. But they offer the\n * convenience of\n * 1) not having to convert the inputs into Tensors,\n * 2) not having to convert the returned Tensors to numbers.\n */\nimport { ValueError } from '../errors';\n/**\n * Determine if a number is an integer.\n */\n\nexport function isInteger(x) {\n  return x === parseInt(x.toString(), 10);\n}\n/**\n * Calculate the product of an array of numbers.\n * @param array The array to calculate the product over.\n * @param begin Beginning index, inclusive.\n * @param end Ending index, exclusive.\n * @return The product.\n */\n\nexport function arrayProd(array, begin, end) {\n  if (begin == null) {\n    begin = 0;\n  }\n\n  if (end == null) {\n    end = array.length;\n  }\n\n  var prod = 1;\n\n  for (var i = begin; i < end; ++i) {\n    prod *= array[i];\n  }\n\n  return prod;\n}\n/**\n * Compute minimum value.\n * @param array\n * @return minimum value.\n */\n\nexport function min(array) {\n  // same behavior as tf.min()\n  if (array.length === 0) {\n    return Number.NaN;\n  }\n\n  var min = Number.POSITIVE_INFINITY;\n\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i];\n\n    if (value < min) {\n      min = value;\n    }\n  }\n\n  return min;\n}\n/**\n * Compute maximum value.\n * @param array\n * @return maximum value\n */\n\nexport function max(array) {\n  // same behavior as tf.max()\n  if (array.length === 0) {\n    return Number.NaN;\n  }\n\n  var max = Number.NEGATIVE_INFINITY;\n\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i];\n\n    if (value > max) {\n      max = value;\n    }\n  }\n\n  return max;\n}\n/**\n * Compute sum of array.\n * @param array\n * @return The sum.\n */\n\nexport function sum(array) {\n  var sum = 0;\n\n  for (var i = 0; i < array.length; i++) {\n    var value = array[i];\n    sum += value;\n  }\n\n  return sum;\n}\n/**\n * Compute mean of array.\n * @param array\n * @return The mean.\n */\n\nexport function mean(array) {\n  return sum(array) / array.length;\n}\n/**\n * Compute variance of array.\n * @param array\n * @return The variance.\n */\n\nexport function variance(array) {\n  var meanValue = mean(array);\n  var demeaned = array.map(function (value) {\n    return value - meanValue;\n  });\n  var sumSquare = 0;\n\n  for (var i = 0; i < demeaned.length; i++) {\n    var value = demeaned[i];\n    sumSquare += value * value;\n  }\n\n  return sumSquare / array.length;\n}\n/**\n * Compute median of array.\n * @param array\n * @return The median value.\n */\n\nexport function median(array) {\n  var arraySorted = array.slice().sort(function (a, b) {\n    return a - b;\n  });\n  var lowIdx = Math.floor((arraySorted.length - 1) / 2);\n  var highIdx = Math.ceil((arraySorted.length - 1) / 2);\n\n  if (lowIdx === highIdx) {\n    return arraySorted[lowIdx];\n  }\n\n  return (arraySorted[lowIdx] + arraySorted[highIdx]) / 2;\n}\n/**\n * Generate an array of integers in [begin, end).\n * @param begin Beginning integer, inclusive.\n * @param end Ending integer, exclusive.\n * @returns Range array.\n * @throws ValueError, iff `end` < `begin`.\n */\n\nexport function range(begin, end) {\n  if (end < begin) {\n    throw new ValueError(\"end (\".concat(end, \") < begin (\").concat(begin, \") is forbidden.\"));\n  }\n\n  var out = [];\n\n  for (var i = begin; i < end; ++i) {\n    out.push(i);\n  }\n\n  return out;\n}","map":null,"metadata":{},"sourceType":"module"}