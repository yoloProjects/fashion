{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { UnsortedSegmentSum, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { cast } from './Cast';\nimport { equal } from './Equal';\nimport { expandDims } from './ExpandDims';\nimport { multiply } from './Multiply';\nimport { pack } from './Pack';\nimport { sum } from './Sum';\nexport function unsortedSegmentSum(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var x = inputs.x,\n      segmentIds = inputs.segmentIds;\n  var numSegments = attrs.numSegments;\n  assertNotComplex(x, 'unsortedSegmentSum');\n  var xRank = x.shape.length;\n  var segmentIdsRank = segmentIds.shape.length;\n  var res = [];\n  var intermediates = []; // Reshape the segment id's so that they can be broadcast with\n  // x. The new shape should be [segmentIds.shape, 1, ..., 1]\n\n  var numIters = xRank - segmentIdsRank;\n  var $segmentIds = segmentIds;\n\n  for (var i = 0; i < numIters; ++i) {\n    var expanded = expandDims({\n      inputs: {\n        input: $segmentIds\n      },\n      backend: backend,\n      attrs: {\n        dim: i + 1\n      }\n    });\n    $segmentIds = expanded;\n    intermediates.push(expanded);\n  }\n\n  for (var _i = 0; _i < numSegments; ++_i) {\n    var scalarValue = util.createScalarValue(_i, 'int32');\n    var segmentId = backend.makeTensorInfo([], 'int32', scalarValue);\n    var mask = equal({\n      inputs: {\n        a: segmentId,\n        b: $segmentIds\n      },\n      backend: backend\n    });\n    var maskCasted = cast({\n      inputs: {\n        x: mask\n      },\n      backend: backend,\n      attrs: {\n        dtype: 'float32'\n      }\n    });\n    var mul = multiply({\n      inputs: {\n        a: maskCasted,\n        b: x\n      },\n      backend: backend\n    });\n    var sumTensorInfo = sum({\n      inputs: {\n        x: mul\n      },\n      backend: backend,\n      attrs: {\n        axis: 0,\n        keepDims: false\n      }\n    });\n    res.push(sumTensorInfo);\n    intermediates.push(segmentId);\n    intermediates.push(mask);\n    intermediates.push(maskCasted);\n    intermediates.push(mul);\n    intermediates.push(sumTensorInfo);\n  }\n\n  var result = pack({\n    inputs: res,\n    backend: backend,\n    attrs: {\n      axis: 0\n    }\n  });\n  intermediates.forEach(function (t) {\n    return backend.disposeIntermediateTensorInfo(t);\n  });\n  return result;\n}\nexport var unsortedSegmentSumConfig = {\n  kernelName: UnsortedSegmentSum,\n  backendName: 'cpu',\n  kernelFunc: unsortedSegmentSum\n};","map":null,"metadata":{},"sourceType":"module"}