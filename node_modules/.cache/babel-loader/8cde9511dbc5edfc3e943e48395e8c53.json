{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from '@tensorflow/tfjs-core';\nexport function pool(xValues, xShape, dtype, strides, convInfo, poolType) {\n  var strideHeight = convInfo.strideHeight;\n  var strideWidth = convInfo.strideWidth;\n  var dilationHeight = convInfo.dilationHeight;\n  var dilationWidth = convInfo.dilationWidth;\n  var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  var padTop = convInfo.padInfo.top;\n  var padLeft = convInfo.padInfo.left;\n  var initialValue = poolType === 'max' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  var output = buffer(convInfo.outShape, dtype);\n  var outputVals = output.values;\n  var outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3];\n  var outputRowStrides = convInfo.outShape[2] * convInfo.outShape[3];\n  var outputColStrides = convInfo.outShape[3];\n\n  for (var b = 0; b < convInfo.batchSize; ++b) {\n    var outputBatchOffset = b * outputBatchStrides;\n    var inputBatchOffset = b * strides[0];\n\n    for (var d = 0; d < convInfo.inChannels; ++d) {\n      for (var yR = 0; yR < convInfo.outHeight; ++yR) {\n        var xRCorner = yR * strideHeight - padTop;\n        var xRMin = Math.max(0, xRCorner);\n        var xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n        var outputRowOffset = outputBatchOffset + yR * outputRowStrides;\n\n        for (var yC = 0; yC < convInfo.outWidth; ++yC) {\n          var xCCorner = yC * strideWidth - padLeft;\n          var xCMin = Math.max(0, xCCorner);\n          var xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n          var minMaxValue = initialValue;\n          var avgValue = 0;\n          var count = 0;\n\n          for (var xR = xRMin; xR < xRMax; xR += dilationHeight) {\n            var xROffset = inputBatchOffset + xR * strides[1];\n\n            for (var xC = xCMin; xC < xCMax; xC += dilationWidth) {\n              var xCOffset = xROffset + xC * strides[2];\n              var pixel = xValues[xCOffset + d];\n\n              if (poolType === 'max' && pixel > minMaxValue) {\n                minMaxValue = pixel;\n              } else if (poolType === 'avg') {\n                avgValue += pixel;\n                count++;\n              }\n            }\n\n            if (isNaN(minMaxValue)) {\n              break;\n            }\n          }\n\n          var outputOffset = outputRowOffset + yC * outputColStrides + d;\n          outputVals[outputOffset] = poolType === 'avg' ? avgValue / count : minMaxValue;\n        }\n      }\n    }\n  }\n\n  return output;\n}\nexport function maxPoolPositions(xValues, xShape, dtype, convInfo) {\n  var flattenPositions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var includeBatchInIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var maxPositions = buffer(convInfo.outShape, 'int32');\n  var strideHeight = convInfo.strideHeight;\n  var strideWidth = convInfo.strideWidth;\n  var dilationHeight = convInfo.dilationHeight;\n  var dilationWidth = convInfo.dilationWidth;\n  var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  var padTop = convInfo.padInfo.top;\n  var padLeft = convInfo.padInfo.left;\n  var xBuf = buffer(xShape, dtype, xValues);\n\n  for (var b = 0; b < convInfo.batchSize; ++b) {\n    for (var d = 0; d < convInfo.inChannels; ++d) {\n      for (var yR = 0; yR < convInfo.outHeight; ++yR) {\n        var xRCorner = yR * strideHeight - padTop;\n        var xRMin = xRCorner;\n\n        while (xRMin < 0) {\n          xRMin += dilationHeight;\n        } // const xRMin = Math.max(0, xRCorner);\n\n\n        var xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n\n        for (var yC = 0; yC < convInfo.outWidth; ++yC) {\n          var xCCorner = yC * strideWidth - padLeft;\n          var xCMin = xCCorner;\n\n          while (xCMin < 0) {\n            xCMin += dilationWidth;\n          }\n\n          var xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n          var maxValue = Number.NEGATIVE_INFINITY;\n          var maxPosition = -1;\n\n          for (var xR = xRMin; xR < xRMax; xR += dilationHeight) {\n            var wR = xR - xRCorner;\n\n            for (var xC = xCMin; xC < xCMax; xC += dilationWidth) {\n              var wC = xC - xCCorner;\n              var pixel = xBuf.get(b, xR, xC, d);\n\n              if (pixel > maxValue) {\n                maxValue = pixel;\n\n                if (flattenPositions) {\n                  maxPosition = includeBatchInIndex ? ((b * convInfo.inHeight + xR) * convInfo.inWidth + xC) * convInfo.inChannels + d : (xR * convInfo.inWidth + xC) * convInfo.inChannels + d;\n                } else {\n                  maxPosition = wR * effectiveFilterWidth + wC;\n                }\n              }\n            }\n          }\n\n          maxPositions.set(maxPosition, b, yR, yC, d);\n        }\n      }\n    }\n  }\n\n  return maxPositions;\n}\nexport function pool3d(xValues, xShape, dtype, strides, convInfo, poolType) {\n  var strideDepth = convInfo.strideDepth;\n  var strideHeight = convInfo.strideHeight;\n  var strideWidth = convInfo.strideWidth;\n  var dilationDepth = convInfo.dilationDepth;\n  var dilationHeight = convInfo.dilationHeight;\n  var dilationWidth = convInfo.dilationWidth;\n  var effectiveFilterDepth = convInfo.effectiveFilterDepth;\n  var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  var padFront = convInfo.padInfo.front;\n  var padTop = convInfo.padInfo.top;\n  var padLeft = convInfo.padInfo.left;\n  var initialValue = poolType === 'max' ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n  var output = buffer(convInfo.outShape, dtype);\n  var outputVals = output.values;\n  var outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n  var outputDepthStrides = convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n  var outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];\n  var outputColStrides = convInfo.outShape[4];\n\n  for (var batch = 0; batch < convInfo.batchSize; ++batch) {\n    var outputBatchOffset = batch * outputBatchStrides;\n    var inputBatchOffset = batch * strides[0];\n\n    for (var channel = 0; channel < convInfo.inChannels; ++channel) {\n      for (var yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n        var xDepthCorner = yDepth * strideDepth - padFront;\n        var xDepthMin = xDepthCorner;\n\n        while (xDepthMin < 0) {\n          xDepthMin += dilationDepth;\n        }\n\n        var xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n        var outputDepthOffset = outputBatchOffset + yDepth * outputDepthStrides;\n\n        for (var yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n          var xRowCorner = yRow * strideHeight - padTop;\n          var xRowMin = xRowCorner;\n\n          while (xRowMin < 0) {\n            xRowMin += dilationHeight;\n          }\n\n          var xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n          var outputRowOffset = outputDepthOffset + yRow * outputRowStrides;\n\n          for (var yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n            var xColCorner = yCol * strideWidth - padLeft;\n            var xColMin = xColCorner;\n\n            while (xColMin < 0) {\n              xColMin += dilationWidth;\n            }\n\n            var xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner); // Shader code begins\n\n            var outputColOffset = outputRowOffset + yCol * outputColStrides;\n            var minMaxValue = initialValue;\n            var avgValue = 0;\n            var count = 0;\n\n            for (var xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n              var xDepthOffset = inputBatchOffset + xDepth * strides[1];\n\n              for (var xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                var xRowOffset = xDepthOffset + xRow * strides[2];\n\n                for (var xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                  var xColOffset = xRowOffset + xCol * strides[3];\n                  var pixel = xValues[xColOffset + channel];\n\n                  if (poolType === 'max' && pixel > minMaxValue) {\n                    minMaxValue = pixel;\n                  } else if (poolType === 'avg') {\n                    avgValue += pixel;\n                    count++;\n                  }\n\n                  if (isNaN(minMaxValue)) {\n                    break;\n                  }\n                }\n\n                if (isNaN(minMaxValue)) {\n                  break;\n                }\n              }\n\n              if (isNaN(minMaxValue)) {\n                break;\n              }\n            }\n\n            var outputOffset = outputColOffset + channel;\n            outputVals[outputOffset] = poolType === 'avg' ? avgValue / count : minMaxValue;\n          }\n        }\n      }\n    }\n  }\n\n  return output;\n}\nexport function maxPool3dPositions(xBuf, convInfo) {\n  var maxPositions = buffer(convInfo.outShape, 'int32');\n  var strideDepth = convInfo.strideDepth;\n  var strideHeight = convInfo.strideHeight;\n  var strideWidth = convInfo.strideWidth;\n  var dilationDepth = convInfo.dilationDepth;\n  var dilationHeight = convInfo.dilationHeight;\n  var dilationWidth = convInfo.dilationWidth;\n  var effectiveFilterDepth = convInfo.effectiveFilterDepth;\n  var effectiveFilterHeight = convInfo.effectiveFilterHeight;\n  var effectiveFilterWidth = convInfo.effectiveFilterWidth;\n  var padFront = convInfo.padInfo.front;\n  var padTop = convInfo.padInfo.top;\n  var padLeft = convInfo.padInfo.left;\n\n  for (var batch = 0; batch < convInfo.batchSize; ++batch) {\n    for (var channel = 0; channel < convInfo.inChannels; ++channel) {\n      for (var yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n        var xDepthCorner = yDepth * strideDepth - padFront;\n        var xDepthMin = xDepthCorner;\n\n        while (xDepthMin < 0) {\n          xDepthMin += dilationDepth;\n        }\n\n        var xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n\n        for (var yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n          var xRowCorner = yRow * strideHeight - padTop;\n          var xRowMin = xRowCorner;\n\n          while (xRowMin < 0) {\n            xRowMin += dilationHeight;\n          }\n\n          var xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n\n          for (var yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n            var xColCorner = yCol * strideWidth - padLeft;\n            var xColMin = xColCorner;\n\n            while (xColMin < 0) {\n              xColMin += dilationWidth;\n            }\n\n            var xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner); // Shader code begins\n\n            var maxValue = Number.NEGATIVE_INFINITY;\n            var maxPosition = -1;\n\n            for (var xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n              var wDepth = xDepth - xDepthCorner;\n\n              for (var xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                var wRow = xRow - xRowCorner;\n\n                for (var xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                  var wCol = xCol - xColCorner;\n                  var pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);\n\n                  if (pixel >= maxValue) {\n                    maxValue = pixel;\n                    maxPosition = wDepth * effectiveFilterHeight * effectiveFilterWidth + wRow * effectiveFilterHeight + wCol;\n                  }\n                }\n              }\n            }\n\n            maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);\n          }\n        }\n      }\n    }\n  }\n\n  return maxPositions;\n}","map":null,"metadata":{},"sourceType":"module"}