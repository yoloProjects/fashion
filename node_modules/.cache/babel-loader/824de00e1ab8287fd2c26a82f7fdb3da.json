{"ast":null,"code":"import _classCallCheck from \"C:\\\\PythonProjects\\\\For GIt\\\\FashionDetect\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { useShapeUniforms } from './gpgpu_math';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport var CHECK_NAN_SNIPPET = \"\\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\";\nexport var ELU_DER = \"\\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\\n\";\nexport var NOT_EQUAL = \"\\n  return vec4(notEqual(a, b));\\n\";\nexport var BinaryOpPackedProgram = function BinaryOpPackedProgram(op, aShape, bShape) {\n  var checkOutOfBounds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  _classCallCheck(this, BinaryOpPackedProgram);\n\n  this.variableNames = ['A', 'B'];\n  this.supportsBroadcasting = true;\n  this.packedInputs = true;\n  this.packedOutput = true;\n  this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n  var rank = this.outputShape.length;\n  this.enableShapeUniforms = useShapeUniforms(rank);\n  var checkOutOfBoundsString = '';\n\n  if (checkOutOfBounds) {\n    if (rank === 0 || util.sizeFromShape(this.outputShape) === 1) {\n      checkOutOfBoundsString = \"\\n          result.y = 0.;\\n          result.z = 0.;\\n          result.w = 0.;\\n        \";\n    } else {\n      var dtype = getCoordsDataType(rank);\n      checkOutOfBoundsString = \"\\n          \".concat(dtype, \" coords = getOutputCoords();\\n        \");\n\n      if (rank === 1) {\n        if (this.enableShapeUniforms) {\n          checkOutOfBoundsString += \"\\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\\n            result.z = 0.;\\n            result.w = 0.;\\n          \";\n        } else {\n          checkOutOfBoundsString += \"\\n            result.y = (coords + 1) >= \".concat(this.outputShape[0], \" ? 0. : result.y;\\n            result.z = 0.;\\n            result.w = 0.;\\n          \");\n        }\n      } else {\n        var channels = getChannels('coords', rank);\n\n        if (this.enableShapeUniforms) {\n          checkOutOfBoundsString += \"\\n            bool nextRowOutOfBounds =\\n              (\".concat(channels[rank - 2], \" + 1) >= outShape[\").concat(rank, \" - 2];\\n            bool nextColOutOfBounds =\\n              (\").concat(channels[rank - 1], \" + 1) >= outShape[\").concat(rank, \" - 1];\\n            result.y = nextColOutOfBounds ? 0. : result.y;\\n            result.z = nextRowOutOfBounds ? 0. : result.z;\\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\\n          \");\n        } else {\n          checkOutOfBoundsString += \"\\n            bool nextRowOutOfBounds =\\n              (\".concat(channels[rank - 2], \" + 1) >= \").concat(this.outputShape[rank - 2], \";\\n            bool nextColOutOfBounds =\\n              (\").concat(channels[rank - 1], \" + 1) >= \").concat(this.outputShape[rank - 1], \";\\n            result.y = nextColOutOfBounds ? 0. : result.y;\\n            result.z = nextRowOutOfBounds ? 0. : result.z;\\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\\n          \");\n        }\n      }\n    }\n  }\n\n  this.userCode = \"\\n      vec4 binaryOperation(vec4 a, vec4 b) {\\n        \".concat(op, \"\\n      }\\n\\n      void main() {\\n        vec4 a = getAAtOutCoords();\\n        vec4 b = getBAtOutCoords();\\n\\n        vec4 result = binaryOperation(a, b);\\n        \").concat(checkOutOfBoundsString, \"\\n\\n        setOutput(result);\\n      }\\n    \");\n};","map":null,"metadata":{},"sourceType":"module"}