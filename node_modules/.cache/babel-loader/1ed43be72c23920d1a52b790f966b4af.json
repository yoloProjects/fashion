{"ast":null,"code":"import _slicedToArray from \"C:\\\\PythonProjects\\\\For GIt\\\\FashionDetect\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ResizeBilinearGrad, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nexport function resizeBilinearGrad(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var images = inputs.images,\n      dy = inputs.dy;\n  var alignCorners = attrs.alignCorners;\n  assertNotComplex([dy, images], 'resizeBilinearGrad');\n  var imagesStrides = util.computeStrides(images.shape);\n\n  var _images$shape = _slicedToArray(images.shape, 4),\n      batch = _images$shape[0],\n      xHeight = _images$shape[1],\n      xWidth = _images$shape[2],\n      depth = _images$shape[3];\n\n  var _dy$shape = _slicedToArray(dy.shape, 3),\n      yHeight = _dy$shape[1],\n      yWidth = _dy$shape[2];\n\n  var output = new Float32Array(batch * xHeight * xWidth * depth); // In the backwards pass, we want to find the pixels that were generated\n  // for each pixel in the input image the forward pass and add the\n  // corresponding coefficient from dy to the gradient (with some\n  // interpolation).\n\n  var effectiveXSize = [alignCorners && yHeight > 1 ? xHeight - 1 : xHeight, alignCorners && yWidth > 1 ? xWidth - 1 : xWidth];\n  var effectiveYSize = [alignCorners && yHeight > 1 ? yHeight - 1 : yHeight, alignCorners && yWidth > 1 ? yWidth - 1 : yWidth];\n  var heightScale = effectiveXSize[0] / effectiveYSize[0];\n  var widthScale = effectiveXSize[1] / effectiveYSize[1]; // Reference implementation\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/3039375c86a5bbc9610c7725dcaa95d635f87ba2/tensorflow/core/kernels/resize_bilinear_op.cc#L275\n\n  var dyValues = backend.data.get(dy.dataId).values;\n  var offset = 0;\n\n  for (var b = 0; b < batch; b++) {\n    var bOffset = b * imagesStrides[0];\n\n    for (var r = 0; r < yHeight; r++) {\n      var dxR = r * heightScale;\n      var topDxRIndex = Math.floor(dxR);\n      var bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);\n      var topDxROffset = bOffset + topDxRIndex * imagesStrides[1];\n      var bottomDxROffset = bOffset + bottomDxRIndex * imagesStrides[1];\n      var dxRLerp = dxR - topDxRIndex;\n      var inverseDxRLerp = 1.0 - dxRLerp;\n\n      for (var c = 0; c < yWidth; c++) {\n        var dxC = c * widthScale;\n        var leftDxCIndex = Math.floor(dxC);\n        var rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);\n        var dxCLerp = dxC - leftDxCIndex;\n        var inverseDxCLerp = 1.0 - dxCLerp;\n        var topLeftRCOffset = topDxROffset + leftDxCIndex * imagesStrides[2];\n        var topRightRCOffset = topDxROffset + rightDxCIndex * imagesStrides[2];\n        var bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * imagesStrides[2];\n        var bottomRightRCOffset = bottomDxROffset + rightDxCIndex * imagesStrides[2];\n        var inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;\n        var inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;\n        var dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;\n        var dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;\n\n        for (var d = 0; d < depth; d++) {\n          var dyVal = dyValues[offset++];\n          output[topLeftRCOffset + d] += dyVal * inverseDxRLerpTimesInverseDxCLerp;\n          output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;\n          output[bottomLeftRCOffset + d] += dyVal * dxRLerpTimesInverseDxCLerp;\n          output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;\n        }\n      }\n    }\n  }\n\n  return backend.makeTensorInfo([batch, xWidth, xHeight, depth], 'float32', output);\n}\nexport var resizeBilinearGradConfig = {\n  kernelName: ResizeBilinearGrad,\n  backendName: 'cpu',\n  kernelFunc: resizeBilinearGrad\n};","map":null,"metadata":{},"sourceType":"module"}