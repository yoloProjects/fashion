{"ast":null,"code":"import _classCallCheck from \"C:\\\\PythonProjects\\\\Fashion\\\\YOLOTFjf\\\\tfjs-yolov5-example\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\PythonProjects\\\\Fashion\\\\YOLOTFjf\\\\tfjs-yolov5-example\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\n/**\n * The StringNGramsOp class creates ngrams from ragged string data.\n * The constructor contains all attributes related to the operation such as\n * padding widths and strings, and the compute function can be used to\n * compute the ngrams for different ragged tensor inputs.\n */\n\nvar StringNGramsOp = /*#__PURE__*/function () {\n  function StringNGramsOp(separator, nGramWidths, leftPad, rightPad, padWidth, preserveShortSequences) {\n    _classCallCheck(this, StringNGramsOp);\n\n    this.separator = util.encodeString(separator);\n    this.nGramWidths = nGramWidths;\n    this.leftPad = util.encodeString(leftPad);\n    this.rightPad = util.encodeString(rightPad);\n    this.padWidth = padWidth;\n    this.preserveShort = preserveShortSequences;\n  }\n\n  _createClass(StringNGramsOp, [{\n    key: \"getPadWidth\",\n    value: function getPadWidth(nGramWidth) {\n      // Ngrams can be padded with either a fixed pad width or a dynamic pad\n      // width depending on the 'padWidth' arg, but in no case should the padding\n      // ever be wider than 'nGramWidth' - 1.\n      return Math.min(this.padWidth < 0 ? nGramWidth - 1 : this.padWidth, nGramWidth - 1);\n    }\n  }, {\n    key: \"getNumNGrams\",\n    value: function getNumNGrams(length, nGramWidth) {\n      var padWidth = this.getPadWidth(nGramWidth);\n      return Math.max(0, length + 2 * padWidth - nGramWidth + 1);\n    }\n  }, {\n    key: \"createNGrams\",\n    value: function createNGrams(data, splitIndex, output, outputStartIndex, numNGrams, nGramWidth) {\n      var _this = this;\n\n      var _loop = function _loop(nGramIndex) {\n        var padWidth = _this.getPadWidth(nGramWidth);\n\n        var leftPadding = Math.max(0, padWidth - nGramIndex);\n        var rightPadding = Math.max(0, padWidth - (numNGrams - (nGramIndex + 1)));\n        var numTokens = nGramWidth - (leftPadding + rightPadding);\n        var dataStartIndex = splitIndex + (leftPadding > 0 ? 0 : nGramIndex - padWidth); // Calculate the total expected size of the nGram so we can reserve the\n        // correct amount of space in the string.\n\n        var nGramSize = 0; // Size of the left padding.\n\n        nGramSize += leftPadding * _this.leftPad.length; // Size of the tokens.\n\n        for (var n = 0; n < numTokens; ++n) {\n          nGramSize += data[dataStartIndex + n].length;\n        } // Size of the right padding.\n\n\n        nGramSize += rightPadding * _this.rightPad.length; // Size of the separators.\n\n        var numSeparators = leftPadding + rightPadding + numTokens - 1;\n        nGramSize += numSeparators * _this.separator.length; // Build the nGram.\n\n        output[outputStartIndex + nGramIndex] = new Uint8Array(nGramSize);\n        var nGram = output[outputStartIndex + nGramIndex];\n        var nextNGramIndex = 0;\n\n        var appendToNGram = function appendToNGram(str) {\n          return str.forEach(function (value) {\n            return nGram[nextNGramIndex++] = value;\n          });\n        };\n\n        for (var _n = 0; _n < leftPadding; ++_n) {\n          appendToNGram(_this.leftPad);\n          appendToNGram(_this.separator);\n        } // Only output first numTokens - 1 pairs of data and separator\n\n\n        for (var _n2 = 0; _n2 < numTokens - 1; ++_n2) {\n          appendToNGram(data[dataStartIndex + _n2]);\n          appendToNGram(_this.separator);\n        } // Handle case when there are no tokens or no right padding as these\n        // can result in consecutive separators.\n\n\n        if (numTokens > 0) {\n          // If we have tokens, then output last and then pair each separator\n          // with the right padding that follows, to ensure nGram ends either with\n          // the token or with the right pad.\n          appendToNGram(data[dataStartIndex + numTokens - 1]);\n\n          for (var _n3 = 0; _n3 < rightPadding; ++_n3) {\n            appendToNGram(_this.separator);\n            appendToNGram(_this.rightPad);\n          }\n        } else {\n          // If we don't have tokens, then the last item inserted into the nGram\n          // has been the separator from the left padding loop above. Hence,\n          // output right pad and separator and make sure to finish with a\n          // padding, not a separator.\n          for (var _n4 = 0; _n4 < rightPadding - 1; ++_n4) {\n            appendToNGram(_this.rightPad);\n            appendToNGram(_this.separator);\n          }\n\n          appendToNGram(_this.rightPad);\n        }\n      };\n\n      for (var nGramIndex = 0; nGramIndex < numNGrams; ++nGramIndex) {\n        _loop(nGramIndex);\n      }\n    } // Data and splits together form the definition of the ragged tensor,\n    // where data is 1 dimensional and contains the values of the tensor\n    // and splits denotes the indices at which each row starts.\n\n  }, {\n    key: \"compute\",\n    value: function compute(data, splits) {\n      var _this2 = this;\n\n      // Validate that the splits are valid indices into data, only if there are\n      // splits specified.\n      var inputDataSize = data.length;\n      var splitsSize = splits.length;\n\n      if (splitsSize > 0) {\n        var prevSplit = splits[0];\n\n        if (prevSplit !== 0) {\n          throw new Error(\"First split value must be 0, got \".concat(prevSplit));\n        }\n\n        for (var i = 1; i < splitsSize; ++i) {\n          var validSplits = splits[i] >= prevSplit;\n          validSplits = validSplits && splits[i] <= inputDataSize;\n\n          if (!validSplits) {\n            throw new Error(\"Invalid split value \".concat(splits[i], \", must be in [\").concat(prevSplit, \", \").concat(inputDataSize, \"]\"));\n          }\n\n          prevSplit = splits[i];\n        }\n\n        if (prevSplit !== inputDataSize) {\n          throw new Error(\"Last split value must be data size. Expected \".concat(inputDataSize, \", got \").concat(prevSplit));\n        }\n      }\n\n      var numBatchItems = splitsSize - 1;\n      var nGramsSplits = util.getArrayFromDType('int32', splitsSize); // If there is no data or size, return an empty ragged tensor.\n\n      if (inputDataSize === 0 || splitsSize === 0) {\n        var empty = new Array(inputDataSize);\n\n        for (var _i = 0; _i <= numBatchItems; ++_i) {\n          nGramsSplits[_i] = 0;\n        }\n\n        return [empty, nGramsSplits];\n      }\n\n      nGramsSplits[0] = 0;\n\n      var _loop2 = function _loop2(_i2) {\n        var length = splits[_i2] - splits[_i2 - 1];\n        var numNGrams = 0;\n\n        _this2.nGramWidths.forEach(function (nGramWidth) {\n          numNGrams += _this2.getNumNGrams(length, nGramWidth);\n        });\n\n        if (_this2.preserveShort && length > 0 && numNGrams === 0) {\n          numNGrams = 1;\n        }\n\n        nGramsSplits[_i2] = nGramsSplits[_i2 - 1] + numNGrams;\n      };\n\n      for (var _i2 = 1; _i2 <= numBatchItems; ++_i2) {\n        _loop2(_i2);\n      }\n\n      var nGrams = new Array(nGramsSplits[numBatchItems]);\n\n      var _loop3 = function _loop3(_i3) {\n        var splitIndex = splits[_i3];\n        var outputStartIdx = nGramsSplits[_i3];\n\n        _this2.nGramWidths.forEach(function (nGramWidth) {\n          var length = splits[_i3 + 1] - splits[_i3];\n\n          var numNGrams = _this2.getNumNGrams(length, nGramWidth);\n\n          _this2.createNGrams(data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);\n\n          outputStartIdx += numNGrams;\n        }); // If we're preserving short sequences, check to see if no sequence was\n        // generated by comparing the current output start idx to the original\n        // one (nGramSplitsdata). If no ngrams were generated, then they will\n        // be equal (since we increment outputStartIdx by numNGrams every\n        // time we create a set of ngrams.)\n\n\n        if (_this2.preserveShort && outputStartIdx === nGramsSplits[_i3]) {\n          var dataLength = splits[_i3 + 1] - splits[_i3]; // One legitimate reason to not have any ngrams when this.preserveShort\n          // is true is if the sequence itself is empty. In that case, move on.\n\n          if (dataLength === 0) {\n            return \"continue\";\n          } // We don't have to worry about dynamic padding sizes here: if padding\n          // was dynamic, every sequence would have had sufficient padding to\n          // generate at least one nGram.\n\n\n          var nGramWidth = dataLength + 2 * _this2.padWidth;\n          var numNGrams = 1;\n\n          _this2.createNGrams(data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);\n        }\n      };\n\n      for (var _i3 = 0; _i3 < numBatchItems; ++_i3) {\n        var _ret = _loop3(_i3);\n\n        if (_ret === \"continue\") continue;\n      }\n\n      return [nGrams, nGramsSplits];\n    }\n  }]);\n\n  return StringNGramsOp;\n}();\n\nexport function stringNGramsImpl(data, dataSplits, separator, nGramWidths, leftPad, rightPad, padWidth, preserveShortSequences) {\n  return new StringNGramsOp(separator, nGramWidths, leftPad, rightPad, padWidth, preserveShortSequences).compute(data, dataSplits);\n}","map":null,"metadata":{},"sourceType":"module"}