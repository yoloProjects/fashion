{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { SparseReshape } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport { op } from '../operation';\n/**\n * This operation has the same semantics as reshape on the represented dense\n * tensor. The `inputIndices` are recomputed based on the requested `newShape`.\n * If one component of `newShape` is the special value -1, the size of that\n * dimension is computed so that the total dense size remains constant. At most\n * one component of `newShape` can be -1. The number of dense elements implied\n * by `newShape` must be the same as the number of dense elements originally\n * implied by `inputShape`. Reshaping does not affect the order of values in the\n * SparseTensor. If the input tensor has rank R_in and N non-empty values, and\n * `newShape` has length R_out, then `inputIndices` has shape [N, R_in],\n * `inputShape` has length R_in, `outputIndices` has shape [N, R_out], and\n * `outputShape` has length R_out.\n *\n * ```js\n * const result = tf.sparse.sparseReshape(\n *   [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]],\n *   [2, 3, 6], [9, -1]);\n * console.log(result);\n * result['outputIndices'].print(); //[[0, 0], [0, 1], [1, 2], [4, 2], [8, 1]]\n * result['outputShape'].print(); // [9, 4]\n * ```\n * @param inputIndices: 2-D. N x R_in matrix with the indices of non-empty\n * values in a SparseTensor.\n * @param inputShape: 1-D. R_in Tensor1D with the input SparseTensor's dense\n * shape.\n * @param newShape: 1-D. R_out Tensor1D with the requested new dense shape.\n * @return A map with the following properties:\n *     - outputIndices: 2-D. N x R_out matrix with the updated indices of\n *       non-empty values in the output SparseTensor.\n *     - outputShape: 1-D. R_out vector with the full dense shape of the output\n *       SparseTensor. This is the same as newShape but with any -1 dimensions\n *        filled in.\n * @doc {heading: 'Operations', subheading: 'Sparse'}\n */\n\nfunction sparseReshape_(inputIndices, inputShape, newShape) {\n  var $inputIndices = convertToTensor(inputIndices, 'inputIndices', 'sparseReshape');\n  var $inputShape = convertToTensor(inputShape, 'inputShape', 'sparseReshape');\n  var $newShape = convertToTensor(newShape, 'newShape', 'sparseReshape');\n\n  if ($inputIndices.rank !== 2) {\n    throw new Error(\"Input indices should be Tensor2D but received shape\\n        \".concat($inputIndices.shape));\n  }\n\n  if ($inputShape.rank !== 1) {\n    throw new Error(\"Input shape should be Tensor1D but received shape \".concat($inputShape.shape));\n  }\n\n  if ($newShape.rank !== 1) {\n    throw new Error(\"New shape should be Tensor1D but received shape \".concat($newShape.shape));\n  }\n\n  var inputs = {\n    inputIndices: $inputIndices,\n    inputShape: $inputShape,\n    newShape: $newShape\n  };\n  var result = ENGINE.runKernel(SparseReshape, inputs);\n  return {\n    outputIndices: result[0],\n    outputShape: result[1]\n  };\n}\n\nexport var sparseReshape = op({\n  sparseReshape_: sparseReshape_\n});","map":null,"metadata":{},"sourceType":"module"}