{"ast":null,"code":"import _slicedToArray from \"C:\\\\PythonProjects\\\\Fashion\\\\YOLOTFjf\\\\tfjs-yolov5-example\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { tensor1d } from '../tensor1d';\nimport { op } from '../operation';\nimport { cast } from '../cast';\nimport { split } from '../split';\nimport { bincount } from '../bincount';\nimport { lessEqual } from '../less_equal';\nimport { greater } from '../greater';\nimport { sum } from '../sum';\nimport { add } from '../add';\nimport { mul } from '../mul';\nimport { div } from '../div';\nimport { sub } from '../sub';\nimport { round } from '../round';\nimport { where } from '../where';\nimport { fill } from '../fill';\nimport { slice } from '../slice';\nimport { range } from '../range';\nimport { tensor } from '../tensor';\nimport * as util from '../../util';\nimport { convertToTensor } from '../../tensor_util_env';\n/**\n * Performs image binarization with corresponding threshold\n * (depends on the method)value, which creates a binary image from a grayscale.\n * @param image 3d tensor of shape [imageHeight,imageWidth, depth],\n * where imageHeight and imageWidth must be positive.The image color\n * range should be [0, 255].\n * @param method Optional string from `'binary' | 'otsu'`\n * which specifies the method for thresholding. Defaults to 'binary'.\n * @param inverted Optional boolean whichspecifies\n * if colours should be inverted. Defaults to false.\n * @param threshValue Optional number which defines threshold value from 0 to 1.\n * Defaults to 0.5.\n * @return A 3d tensor of shape [imageHeight,imageWidth, depth], which\n * contains binarized image.\n */\n\nfunction threshold_(image) {\n  var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'binary';\n  var inverted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var threshValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;\n  var $image = convertToTensor(image, 'image', 'threshold');\n  /* 0.2989, 0.5870, 0.1140 are represent luma coefficients in CCIR601.\n  Reference for converting between RGB and grayscale: https://en.wikipedia.org/wiki/Luma_%28video%29  */\n\n  var RED_INTENCITY_COEF = 0.2989;\n  var GREEN_INTENCITY_COEF = 0.5870;\n  var BLUE_INTENCITY_COEF = 0.1140;\n  var totalPixelsInImage = $image.shape[0] * $image.shape[1];\n  var $threshold = mul(tensor1d([threshValue]), 255);\n  var r, g, b, grayscale;\n  util.assert($image.rank === 3, function () {\n    return 'Error in threshold: image must be rank 3,' + \"but got rank \".concat($image.rank, \".\");\n  });\n  util.assert($image.shape[2] === 3 || $image.shape[2] === 1, function () {\n    return 'Error in threshold: ' + 'image color channel must be equal to 3 or 1' + \"but got \".concat($image.shape[2], \".\");\n  });\n  util.assert($image.dtype === 'int32' || $image.dtype === 'float32', function () {\n    return 'Error in dtype: image dtype must be int32 or float32,' + \"but got dtype \".concat($image.dtype, \".\");\n  });\n  util.assert(method === 'otsu' || method === 'binary', function () {\n    return \"Method must be binary or otsu, but was \".concat(method);\n  });\n\n  if ($image.shape[2] === 3) {\n    var _split = split($image, [1, 1, 1], -1);\n\n    var _split2 = _slicedToArray(_split, 3);\n\n    r = _split2[0];\n    g = _split2[1];\n    b = _split2[2];\n    var $r = mul(r, RED_INTENCITY_COEF);\n    var $g = mul(g, GREEN_INTENCITY_COEF);\n    var $b = mul(b, BLUE_INTENCITY_COEF);\n    grayscale = add(add($r, $g), $b);\n  } else {\n    grayscale = image;\n  }\n\n  if (method === 'otsu') {\n    var $histogram = bincount(cast(round(grayscale), 'int32'), tensor([]), 256);\n    $threshold = otsu($histogram, totalPixelsInImage);\n  }\n\n  var invCondition = inverted ? lessEqual(grayscale, $threshold) : greater(grayscale, $threshold);\n  var result = cast(mul(invCondition, 255), 'int32');\n  return result;\n}\n\nfunction otsu(histogram, total) {\n  var bestThresh = tensor1d([-1]);\n  var bestInBetVar = tensor1d([0]);\n  var cInBetVar = tensor1d([0]);\n  var classFirst, classSecond, meanFirst, meanSec, weightForeground, weightBack;\n\n  for (var index = 0; index < histogram.size - 1; index++) {\n    classFirst = slice(histogram, 0, index + 1);\n    classSecond = slice(histogram, index + 1);\n    weightForeground = div(sum(classFirst), total);\n    weightBack = div(sum(classSecond), total);\n    var meanFirstDivA = sum(mul(classFirst, range(0, classFirst.size)));\n    meanFirst = div(meanFirstDivA, sum(classFirst));\n    var meanSecFill = fill(classSecond.shape, classFirst.size);\n    var meanSecAdd = add(range(0, classSecond.size), meanSecFill);\n    var meanSecMul = mul(classSecond, meanSecAdd);\n    meanSec = div(sum(meanSecMul), sum(classSecond));\n    var cInBetVarSubA = sub(meanFirst, meanSec);\n    var cInBetVarSubB = sub(meanFirst, meanSec);\n    var cInBetVarMul = mul(weightForeground, weightBack);\n    cInBetVar = mul(mul(cInBetVarMul, cInBetVarSubA), cInBetVarSubB);\n    var condition = greater(cInBetVar, bestInBetVar);\n    bestInBetVar = where(condition, cInBetVar, bestInBetVar);\n    bestThresh = where(condition, tensor1d([index]), bestThresh);\n  }\n\n  return bestThresh;\n}\n\nexport var threshold = op({\n  threshold_: threshold_\n});","map":null,"metadata":{},"sourceType":"module"}