{"ast":null,"code":"import _slicedToArray from \"C:\\\\PythonProjects\\\\Fashion\\\\YOLOTFjf\\\\tfjs-yolov5-example\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"C:\\\\PythonProjects\\\\Fashion\\\\YOLOTFjf\\\\tfjs-yolov5-example\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"C:\\\\PythonProjects\\\\Fashion\\\\YOLOTFjf\\\\tfjs-yolov5-example\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"C:\\\\PythonProjects\\\\Fashion\\\\YOLOTFjf\\\\tfjs-yolov5-example\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\PythonProjects\\\\Fashion\\\\YOLOTFjf\\\\tfjs-yolov5-example\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\PythonProjects\\\\Fashion\\\\YOLOTFjf\\\\tfjs-yolov5-example\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\PythonProjects\\\\Fashion\\\\YOLOTFjf\\\\tfjs-yolov5-example\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\PythonProjects\\\\Fashion\\\\YOLOTFjf\\\\tfjs-yolov5-example\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"C:\\\\PythonProjects\\\\Fashion\\\\YOLOTFjf\\\\tfjs-yolov5-example\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Import webgl flags.\nimport './flags_webgl';\nimport { backend_util, buffer, DataStorage, engine, env, kernel_impls, KernelBackend, scalar, tidy, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext } from './canvas_util';\nimport { DecodeMatrixProgram } from './decode_matrix_gpu';\nimport { DecodeMatrixPackedProgram } from './decode_matrix_packed_gpu';\nimport { EncodeFloatProgram } from './encode_float_gpu';\nimport { EncodeFloatPackedProgram } from './encode_float_packed_gpu';\nimport { EncodeMatrixProgram } from './encode_matrix_gpu';\nimport { EncodeMatrixPackedProgram } from './encode_matrix_packed_gpu';\nimport { GPGPUContext } from './gpgpu_context';\nimport * as gpgpu_math from './gpgpu_math';\nimport { simpleAbsImplCPU } from './kernel_utils/shared';\nimport { PackProgram } from './pack_gpu';\nimport { ReshapePackedProgram } from './reshape_packed_gpu';\nimport * as tex_util from './tex_util';\nimport { TextureUsage } from './tex_util';\nimport { TextureManager } from './texture_manager';\nimport * as unary_op from './unaryop_gpu';\nimport { UnaryOpProgram } from './unaryop_gpu';\nimport { UnaryOpPackedProgram } from './unaryop_packed_gpu';\nimport { UnpackProgram } from './unpack_gpu';\nimport * as webgl_util from './webgl_util';\nvar whereImpl = kernel_impls.whereImpl;\nexport var EPSILON_FLOAT32 = 1e-7;\nexport var EPSILON_FLOAT16 = 1e-4;\nvar binaryCaches = {};\nexport function getBinaryCache(webGLVersion) {\n  if (webGLVersion in binaryCaches) {\n    return binaryCaches[webGLVersion];\n  }\n\n  binaryCaches[webGLVersion] = {};\n  return binaryCaches[webGLVersion];\n} // Empirically determined constant used to determine size threshold for handing\n// off execution to the CPU.\n\nvar CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber('CPU_HANDOFF_SIZE_THRESHOLD'); // Empirically determined constant used to decide the number of MB on GPU\n// before we warn about high memory use. The MB are this constant * screen area\n// * dpi / 1024 / 1024.\n\nvar BEFORE_PAGING_CONSTANT = 600;\n\nfunction numMBBeforeWarning() {\n  if (env().global.screen == null) {\n    return 1024; // 1 GB.\n  }\n\n  return env().global.screen.height * env().global.screen.width * window.devicePixelRatio * BEFORE_PAGING_CONSTANT / 1024 / 1024;\n}\n\nexport var MathBackendWebGL = /*#__PURE__*/function (_KernelBackend) {\n  _inherits(MathBackendWebGL, _KernelBackend);\n\n  function MathBackendWebGL(gpgpu) {\n    var _this;\n\n    _classCallCheck(this, MathBackendWebGL);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MathBackendWebGL).call(this)); // Maps data ids that have a pending read operation, to list of subscribers.\n\n    _this.pendingRead = new WeakMap(); // List of data ids that are scheduled for disposal, but are waiting on a\n    // pending read operation.\n\n    _this.pendingDisposal = new WeakSet(); // Used to count the number of 'shallow' sliced tensors that point to the\n    // same data id.\n\n    _this.dataRefCount = new WeakMap();\n    _this.numBytesInGPU = 0; // Accumulated time spent (including blocking) in uploading data to webgl.\n\n    _this.uploadWaitMs = 0; // Accumulated time spent (including blocking in downloading data from webgl.\n\n    _this.downloadWaitMs = 0; // record the last manual GL Flush time.\n\n    _this.lastGlFlushTime = 0;\n    _this.warnedAboutMemory = false;\n    _this.pendingDeletes = 0;\n    _this.disposed = false;\n\n    if (!env().getBool('HAS_WEBGL')) {\n      throw new Error('WebGL is not supported on this device');\n    }\n\n    if (gpgpu == null) {\n      var gl = getWebGLContext(env().getNumber('WEBGL_VERSION'));\n      _this.binaryCache = getBinaryCache(env().getNumber('WEBGL_VERSION'));\n      _this.gpgpu = new GPGPUContext(gl);\n      _this.canvas = gl.canvas;\n      _this.gpgpuCreatedLocally = true;\n    } else {\n      _this.gpgpu = gpgpu;\n      _this.binaryCache = {};\n      _this.gpgpuCreatedLocally = false;\n      _this.canvas = gpgpu.gl.canvas;\n    }\n\n    _this.textureManager = new TextureManager(_this.gpgpu);\n    _this.numMBBeforeWarning = numMBBeforeWarning();\n    _this.texData = new DataStorage(_assertThisInitialized(_assertThisInitialized(_this)), engine());\n    return _this;\n  }\n\n  _createClass(MathBackendWebGL, [{\n    key: \"nextDataId\",\n    value: function nextDataId() {\n      return MathBackendWebGL.nextDataId++;\n    }\n  }, {\n    key: \"numDataIds\",\n    value: function numDataIds() {\n      return this.texData.numDataIds() - this.pendingDeletes;\n    }\n  }, {\n    key: \"write\",\n    value: function write(values, shape, dtype) {\n      if (env().getBool('WEBGL_CHECK_NUMERICAL_PROBLEMS') || env().getBool('DEBUG')) {\n        this.checkNumericalProblems(values);\n      }\n\n      if (dtype === 'complex64' && values != null) {\n        throw new Error(\"Cannot write to a complex64 dtype. \" + \"Please use tf.complex(real, imag).\");\n      }\n\n      var dataId = {\n        id: this.nextDataId()\n      };\n      this.texData.set(dataId, {\n        shape: shape,\n        dtype: dtype,\n        values: values,\n        usage: TextureUsage.UPLOAD,\n        refCount: 1\n      });\n      return dataId;\n    }\n    /** Return refCount of a `TensorData`. */\n\n  }, {\n    key: \"refCount\",\n    value: function refCount(dataId) {\n      if (this.texData.has(dataId)) {\n        var tensorData = this.texData.get(dataId);\n        return tensorData.refCount;\n      }\n\n      return 0;\n    }\n    /** Increase refCount of a `TextureData`. */\n\n  }, {\n    key: \"incRef\",\n    value: function incRef(dataId) {\n      var texData = this.texData.get(dataId);\n      texData.refCount++;\n    }\n    /** Decrease refCount of a `TextureData`. */\n\n  }, {\n    key: \"decRef\",\n    value: function decRef(dataId) {\n      if (this.texData.has(dataId)) {\n        var texData = this.texData.get(dataId);\n        texData.refCount--;\n      }\n    }\n  }, {\n    key: \"move\",\n    value: function move(dataId, values, shape, dtype, refCount) {\n      if (env().getBool('DEBUG')) {\n        this.checkNumericalProblems(values);\n      }\n\n      if (dtype === 'complex64') {\n        throw new Error(\"Cannot write to a complex64 dtype. \" + \"Please use tf.complex(real, imag).\");\n      }\n\n      this.texData.set(dataId, {\n        shape: shape,\n        dtype: dtype,\n        values: values,\n        usage: TextureUsage.UPLOAD,\n        refCount: refCount\n      });\n    }\n  }, {\n    key: \"disposeIntermediateTensorInfo\",\n    value: function disposeIntermediateTensorInfo(tensorInfo) {\n      this.disposeData(tensorInfo.dataId);\n    }\n  }, {\n    key: \"readSync\",\n    value: function readSync(dataId) {\n      var texData = this.texData.get(dataId);\n      var values = texData.values,\n          dtype = texData.dtype,\n          complexTensorInfos = texData.complexTensorInfos,\n          slice = texData.slice,\n          shape = texData.shape,\n          isPacked = texData.isPacked; // The presence of `slice` indicates this tensor is a shallow slice of a\n      // different tensor, and is using that original tensor's texture. Run\n      // `clone` in order to copy that texture and read from it.\n\n      if (slice != null) {\n        var program;\n\n        if (isPacked) {\n          program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n        } else {\n          program = new UnaryOpProgram(shape, unary_op.CLONE);\n        }\n\n        var res = this.runWebGLProgram(program, [{\n          dataId: dataId,\n          shape: shape,\n          dtype: dtype\n        }], dtype);\n        var data = this.readSync(res.dataId);\n        this.disposeIntermediateTensorInfo(res);\n        return data;\n      }\n\n      if (values != null) {\n        return this.convertAndCacheOnCPU(dataId);\n      }\n\n      if (dtype === 'string') {\n        return values;\n      }\n\n      var shouldTimeProgram = this.activeTimers != null;\n      var start;\n\n      if (shouldTimeProgram) {\n        start = util.now();\n      }\n\n      var result;\n\n      if (dtype === 'complex64') {\n        var realValues = this.readSync(complexTensorInfos.real.dataId);\n        var imagValues = this.readSync(complexTensorInfos.imag.dataId);\n        result = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n      } else {\n        result = this.getValuesFromTexture(dataId);\n      }\n\n      if (shouldTimeProgram) {\n        this.downloadWaitMs += util.now() - start;\n      }\n\n      return this.convertAndCacheOnCPU(dataId, result);\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(dataId) {\n        var _subscribers, texData, values, shape, slice, dtype, complexTensorInfos, isPacked, program, res, data, buffer, tmpDownloadTarget, _this$gpgpu, tmpData, vals, ps, realValues, imagValues, size, gl, dTypeVals, subscribers;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.pendingRead.has(dataId)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                _subscribers = this.pendingRead.get(dataId);\n                return _context.abrupt(\"return\", new Promise(function (resolve) {\n                  return _subscribers.push(resolve);\n                }));\n\n              case 3:\n                texData = this.texData.get(dataId);\n                values = texData.values, shape = texData.shape, slice = texData.slice, dtype = texData.dtype, complexTensorInfos = texData.complexTensorInfos, isPacked = texData.isPacked; // The presence of `slice` indicates this tensor is a shallow slice of a\n                // different tensor, and is using that original tensor's texture. Run\n                // `clone` in order to copy that texture and read from it.\n\n                if (!(slice != null)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                if (isPacked) {\n                  program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n                } else {\n                  program = new UnaryOpProgram(shape, unary_op.CLONE);\n                }\n\n                res = this.runWebGLProgram(program, [{\n                  dataId: dataId,\n                  shape: shape,\n                  dtype: dtype\n                }], dtype);\n                data = this.read(res.dataId);\n                this.disposeIntermediateTensorInfo(res);\n                return _context.abrupt(\"return\", data);\n\n              case 11:\n                if (!(values != null)) {\n                  _context.next = 13;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this.convertAndCacheOnCPU(dataId));\n\n              case 13:\n                if (!(!env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') && env().getNumber('WEBGL_VERSION') === 2)) {\n                  _context.next = 15;\n                  break;\n                }\n\n                throw new Error(\"tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and \" + \"WEBGL_VERSION=2 not yet supported.\");\n\n              case 15:\n                buffer = null;\n\n                if (dtype !== 'complex64' && env().get('WEBGL_BUFFER_SUPPORTED')) {\n                  // Possibly copy the texture into a buffer before inserting a fence.\n                  tmpDownloadTarget = this.decode(dataId);\n                  tmpData = this.texData.get(tmpDownloadTarget.dataId);\n                  buffer = (_this$gpgpu = this.gpgpu).createBufferFromTexture.apply(_this$gpgpu, [tmpData.texture].concat(_toConsumableArray(tex_util.getDenseTexShape(shape))));\n                }\n\n                this.pendingRead.set(dataId, []);\n\n                if (!(dtype !== 'complex64')) {\n                  _context.next = 21;\n                  break;\n                }\n\n                _context.next = 21;\n                return this.gpgpu.createAndWaitForFence();\n\n              case 21:\n                if (!(dtype === 'complex64')) {\n                  _context.next = 30;\n                  break;\n                }\n\n                _context.next = 24;\n                return Promise.all([this.read(complexTensorInfos.real.dataId), this.read(complexTensorInfos.imag.dataId)]);\n\n              case 24:\n                ps = _context.sent;\n                realValues = ps[0];\n                imagValues = ps[1];\n                vals = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n                _context.next = 31;\n                break;\n\n              case 30:\n                if (buffer == null) {\n                  vals = this.getValuesFromTexture(dataId);\n                } else {\n                  size = util.sizeFromShape(shape);\n                  vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer, size);\n                }\n\n              case 31:\n                if (tmpDownloadTarget != null) {\n                  this.disposeIntermediateTensorInfo(tmpDownloadTarget);\n                }\n\n                if (buffer != null) {\n                  gl = this.gpgpu.gl;\n                  webgl_util.callAndCheck(gl, function () {\n                    return gl.deleteBuffer(buffer);\n                  });\n                }\n\n                dTypeVals = this.convertAndCacheOnCPU(dataId, vals);\n                subscribers = this.pendingRead.get(dataId);\n                this.pendingRead.delete(dataId); // Notify all pending reads.\n\n                subscribers.forEach(function (resolve) {\n                  return resolve(dTypeVals);\n                });\n\n                if (this.pendingDisposal.has(dataId)) {\n                  this.pendingDisposal.delete(dataId);\n\n                  if (this.disposeData(dataId)) {\n                    engine().removeDataId(dataId, this);\n                  }\n\n                  this.pendingDeletes--;\n                }\n\n                return _context.abrupt(\"return\", dTypeVals);\n\n              case 39:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function read(_x) {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"bufferSync\",\n    value: function bufferSync(t) {\n      var data = this.readSync(t.dataId);\n      var decodedData = data;\n\n      if (t.dtype === 'string') {\n        try {\n          // Decode the bytes into string.\n          decodedData = data.map(function (d) {\n            return util.decodeString(d);\n          });\n        } catch (_a) {\n          throw new Error('Failed to decode encoded string bytes into utf-8');\n        }\n      }\n\n      return buffer(t.shape, t.dtype, decodedData);\n    }\n  }, {\n    key: \"checkNumericalProblems\",\n    value: function checkNumericalProblems(values) {\n      if (values == null) {\n        return;\n      }\n\n      for (var i = 0; i < values.length; i++) {\n        var num = values[i];\n\n        if (!webgl_util.canBeRepresented(num)) {\n          if (env().getBool('WEBGL_RENDER_FLOAT32_CAPABLE')) {\n            throw Error(\"The value \".concat(num, \" cannot be represented with your \") + \"current settings. Consider enabling float32 rendering: \" + \"'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'\");\n          }\n\n          throw Error(\"The value \".concat(num, \" cannot be represented on this device.\"));\n        }\n      }\n    }\n  }, {\n    key: \"getValuesFromTexture\",\n    value: function getValuesFromTexture(dataId) {\n      var _this$texData$get = this.texData.get(dataId),\n          shape = _this$texData$get.shape,\n          dtype = _this$texData$get.dtype,\n          isPacked = _this$texData$get.isPacked;\n\n      var size = util.sizeFromShape(shape);\n\n      if (env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {\n        var _this$gpgpu2;\n\n        var tmpTarget = this.decode(dataId);\n\n        var _tmpData = this.texData.get(tmpTarget.dataId);\n\n        var _vals = (_this$gpgpu2 = this.gpgpu).downloadMatrixFromPackedTexture.apply(_this$gpgpu2, [_tmpData.texture].concat(_toConsumableArray(tex_util.getDenseTexShape(shape)))).subarray(0, size);\n\n        this.disposeIntermediateTensorInfo(tmpTarget);\n        return _vals;\n      }\n\n      var shouldUsePackedProgram = env().getBool('WEBGL_PACK') && isPacked === true;\n      var outputShape = shouldUsePackedProgram ? webgl_util.getShapeAs3D(shape) : shape;\n      var program = shouldUsePackedProgram ? new EncodeFloatPackedProgram(outputShape) : new EncodeFloatProgram(outputShape);\n      var output = this.runWebGLProgram(program, [{\n        shape: outputShape,\n        dtype: dtype,\n        dataId: dataId\n      }], 'float32');\n      var tmpData = this.texData.get(output.dataId);\n      var vals = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture, tmpData.texShape[0], tmpData.texShape[1]).subarray(0, size);\n      this.disposeIntermediateTensorInfo(output);\n      return vals;\n    }\n  }, {\n    key: \"timerAvailable\",\n    value: function timerAvailable() {\n      return env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0;\n    }\n  }, {\n    key: \"time\",\n    value: function () {\n      var _time = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(f) {\n        var oldActiveTimers, newActiveTimers, outerMostTime, flattenedActiveTimerQueries, flattenedActiveTimerNames, res, kernelMs;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                oldActiveTimers = this.activeTimers;\n                newActiveTimers = [];\n                outerMostTime = false;\n\n                if (this.programTimersStack == null) {\n                  this.programTimersStack = newActiveTimers;\n                  outerMostTime = true;\n                } else {\n                  this.activeTimers.push(newActiveTimers);\n                }\n\n                this.activeTimers = newActiveTimers;\n                f(); // needing to split these up because util.flatten only accepts certain types\n\n                flattenedActiveTimerQueries = util.flatten(this.activeTimers.map(function (d) {\n                  return d.query;\n                })).filter(function (d) {\n                  return d != null;\n                });\n                flattenedActiveTimerNames = util.flatten(this.activeTimers.map(function (d) {\n                  return d.name;\n                })).filter(function (d) {\n                  return d != null;\n                });\n                this.activeTimers = oldActiveTimers;\n\n                if (outerMostTime) {\n                  this.programTimersStack = null;\n                }\n\n                res = {\n                  uploadWaitMs: this.uploadWaitMs,\n                  downloadWaitMs: this.downloadWaitMs,\n                  kernelMs: null,\n                  wallMs: null // will be filled by the engine\n\n                };\n\n                if (!(env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0)) {\n                  _context2.next = 19;\n                  break;\n                }\n\n                _context2.next = 14;\n                return Promise.all(flattenedActiveTimerQueries);\n\n              case 14:\n                kernelMs = _context2.sent;\n                res['kernelMs'] = util.sum(kernelMs);\n\n                res['getExtraProfileInfo'] = function () {\n                  return kernelMs.map(function (d, i) {\n                    return {\n                      name: flattenedActiveTimerNames[i],\n                      ms: d\n                    };\n                  }).map(function (d) {\n                    return \"\".concat(d.name, \": \").concat(d.ms);\n                  }).join(', ');\n                };\n\n                _context2.next = 20;\n                break;\n\n              case 19:\n                res['kernelMs'] = {\n                  error: 'WebGL query timers are not supported in this environment.'\n                };\n\n              case 20:\n                this.uploadWaitMs = 0;\n                this.downloadWaitMs = 0;\n                return _context2.abrupt(\"return\", res);\n\n              case 23:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function time(_x2) {\n        return _time.apply(this, arguments);\n      }\n\n      return time;\n    }()\n  }, {\n    key: \"memory\",\n    value: function memory() {\n      return {\n        unreliable: false,\n        numBytesInGPU: this.numBytesInGPU,\n        numBytesInGPUAllocated: this.textureManager.numBytesAllocated,\n        numBytesInGPUFree: this.textureManager.numBytesFree\n      };\n    }\n  }, {\n    key: \"startTimer\",\n    value: function startTimer() {\n      if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n        return this.gpgpu.beginQuery();\n      }\n\n      return {\n        startMs: util.now(),\n        endMs: null\n      };\n    }\n  }, {\n    key: \"endTimer\",\n    value: function endTimer(query) {\n      if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n        this.gpgpu.endQuery();\n        return query;\n      }\n\n      query.endMs = util.now();\n      return query;\n    }\n  }, {\n    key: \"getQueryTime\",\n    value: function () {\n      var _getQueryTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(query) {\n        var timerQuery;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0)) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this.gpgpu.waitForQueryAndGetTime(query));\n\n              case 2:\n                timerQuery = query;\n                return _context3.abrupt(\"return\", timerQuery.endMs - timerQuery.startMs);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getQueryTime(_x3) {\n        return _getQueryTime.apply(this, arguments);\n      }\n\n      return getQueryTime;\n    }()\n    /**\n     * Decrease the RefCount on the dataId and dispose the memory if the dataId\n     * has 0 refCount. If there are pending read on the data, the disposal would\n     * added to the pending delete queue. Return true if the dataId is removed\n     * from backend or the backend does not contain the dataId, false if the\n     * dataId is not removed. Memory may or may not be released even when dataId\n     * is removed, which also depends on dataRefCount, see `releaseGPU`.\n     * @param dataId\n     * @oaram force Optional, remove the data regardless of refCount\n     */\n\n  }, {\n    key: \"disposeData\",\n    value: function disposeData(dataId) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (this.pendingDisposal.has(dataId)) {\n        return false;\n      } // No-op if already disposed.\n\n\n      if (!this.texData.has(dataId)) {\n        return true;\n      } // if force flag is set, change refCount to 0, this would ensure disposal\n      // when added to the pendingDisposal queue. Memory may or may not be\n      // released, which also depends on dataRefCount, see `releaseGPU`.\n\n\n      if (force) {\n        this.texData.get(dataId).refCount = 0;\n      } else {\n        this.texData.get(dataId).refCount--;\n      }\n\n      if (!force && this.texData.get(dataId).refCount > 0) {\n        return false;\n      }\n\n      if (this.pendingRead.has(dataId)) {\n        this.pendingDisposal.add(dataId);\n        this.pendingDeletes++;\n        return false;\n      }\n\n      this.releaseGPUData(dataId);\n\n      var _this$texData$get2 = this.texData.get(dataId),\n          complexTensorInfos = _this$texData$get2.complexTensorInfos;\n\n      if (complexTensorInfos != null) {\n        this.disposeData(complexTensorInfos.real.dataId, force);\n        this.disposeData(complexTensorInfos.imag.dataId, force);\n      }\n\n      this.texData.delete(dataId);\n      return true;\n    }\n  }, {\n    key: \"releaseGPUData\",\n    value: function releaseGPUData(dataId) {\n      var _this$texData$get3 = this.texData.get(dataId),\n          texture = _this$texData$get3.texture,\n          dtype = _this$texData$get3.dtype,\n          texShape = _this$texData$get3.texShape,\n          usage = _this$texData$get3.usage,\n          isPacked = _this$texData$get3.isPacked,\n          slice = _this$texData$get3.slice;\n\n      var key = slice && slice.origDataId || dataId;\n      var refCount = this.dataRefCount.get(key);\n\n      if (refCount > 1) {\n        this.dataRefCount.set(key, refCount - 1);\n      } else {\n        this.dataRefCount.delete(key);\n\n        if (texture != null) {\n          this.numBytesInGPU -= this.computeBytes(texShape, dtype);\n          this.textureManager.releaseTexture(texture, texShape, usage, isPacked);\n        }\n      }\n\n      var texData = this.texData.get(dataId);\n      texData.texture = null;\n      texData.texShape = null;\n      texData.isPacked = false;\n      texData.slice = null;\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture(dataId) {\n      this.uploadToGPU(dataId);\n      return this.texData.get(dataId).texture;\n    }\n    /**\n     * Returns internal information for the specific data bucket. Used in unit\n     * tests.\n     */\n\n  }, {\n    key: \"getDataInfo\",\n    value: function getDataInfo(dataId) {\n      return this.texData.get(dataId);\n    }\n    /*\n    Tests whether all the inputs to an op are small and on the CPU. This heuristic\n    determines when it would be faster to execute a kernel on the CPU. WebGL\n    kernels opt into running this check and forwarding when appropriate.\n    TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more\n    sustainable strategy for optimizing backend execution of ops.\n     */\n\n  }, {\n    key: \"shouldExecuteOnCPU\",\n    value: function shouldExecuteOnCPU(inputs) {\n      var _this2 = this;\n\n      var sizeThreshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CPU_HANDOFF_SIZE_THRESHOLD;\n      return env().getBool('WEBGL_CPU_FORWARD') && inputs.every(function (input) {\n        return _this2.texData.get(input.dataId).texture == null && util.sizeFromShape(input.shape) < sizeThreshold;\n      });\n    }\n  }, {\n    key: \"getGPGPUContext\",\n    value: function getGPGPUContext() {\n      return this.gpgpu;\n    }\n  }, {\n    key: \"where\",\n    value: function where(condition) {\n      backend_util.warn('tf.where() in webgl locks the UI thread. ' + 'Call tf.whereAsync() instead');\n      var condVals = condition.dataSync();\n      return whereImpl(condition.shape, condVals);\n    }\n  }, {\n    key: \"packedUnaryOp\",\n    value: function packedUnaryOp(x, op, dtype) {\n      var program = new UnaryOpPackedProgram(x.shape, op);\n      var outInfo = this.compileAndRun(program, [x], dtype);\n      return engine().makeTensorFromDataId(outInfo.dataId, outInfo.shape, outInfo.dtype);\n    } // TODO(msoulanille) remove this once the backend has been modularized\n    // a copy is needed here to break a circular dependency.\n    // Also remove the op from unary_op.\n\n  }, {\n    key: \"abs\",\n    value: function abs(x) {\n      // TODO: handle cases when x is complex.\n      if (this.shouldExecuteOnCPU([x]) && x.dtype !== 'complex64') {\n        var outValues = simpleAbsImplCPU(this.texData.get(x.dataId).values);\n        return this.makeOutput(x.shape, x.dtype, outValues);\n      }\n\n      if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n        return this.packedUnaryOp(x, unary_op.ABS, x.dtype);\n      }\n\n      var program = new UnaryOpProgram(x.shape, unary_op.ABS);\n      var outInfo = this.compileAndRun(program, [x]);\n      return engine().makeTensorFromDataId(outInfo.dataId, outInfo.shape, outInfo.dtype);\n    }\n  }, {\n    key: \"makeTensorInfo\",\n    value: function makeTensorInfo(shape, dtype, values) {\n      var dataId;\n\n      if (dtype === 'string' && values != null && values.length > 0 && util.isString(values[0])) {\n        var encodedValues = values.map(function (d) {\n          return util.encodeString(d);\n        });\n        dataId = this.write(encodedValues, shape, dtype);\n      } else {\n        dataId = this.write(values, shape, dtype);\n      }\n\n      this.texData.get(dataId).usage = null;\n      return {\n        dataId: dataId,\n        shape: shape,\n        dtype: dtype\n      };\n    }\n  }, {\n    key: \"makeOutput\",\n    value: function makeOutput(shape, dtype, values) {\n      var _this$makeTensorInfo = this.makeTensorInfo(shape, dtype, values),\n          dataId = _this$makeTensorInfo.dataId;\n\n      return engine().makeTensorFromDataId(dataId, shape, dtype, this);\n    }\n  }, {\n    key: \"unpackTensor\",\n    value: function unpackTensor(input) {\n      var program = new UnpackProgram(input.shape);\n      return this.runWebGLProgram(program, [input], input.dtype);\n    }\n  }, {\n    key: \"packTensor\",\n    value: function packTensor(input) {\n      var program = new PackProgram(input.shape);\n      var preventEagerUnpackingOutput = true;\n      return this.runWebGLProgram(program, [input], input.dtype, null\n      /* customUniformValues */\n      , preventEagerUnpackingOutput);\n    }\n  }, {\n    key: \"packedReshape\",\n    value: function packedReshape(input, afterShape) {\n      var input3DShape = [webgl_util.getBatchDim(input.shape)].concat(_toConsumableArray(webgl_util.getRowsCols(input.shape)));\n      var input3D = {\n        dtype: input.dtype,\n        shape: input3DShape,\n        dataId: input.dataId\n      };\n      var afterShapeAs3D = [webgl_util.getBatchDim(afterShape)].concat(_toConsumableArray(webgl_util.getRowsCols(afterShape)));\n      var program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n      var preventEagerUnpackingOfOutput = true;\n      var customValues = [input3DShape];\n      var output = this.runWebGLProgram(program, [input3D], input.dtype, customValues, preventEagerUnpackingOfOutput);\n      return {\n        dataId: output.dataId,\n        shape: afterShape,\n        dtype: output.dtype\n      };\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(dataId) {\n      var texData = this.texData.get(dataId);\n      var isPacked = texData.isPacked,\n          shape = texData.shape,\n          dtype = texData.dtype;\n      var shapeAs3D = webgl_util.getShapeAs3D(shape);\n      var program;\n      var denseTexShape = tex_util.getDenseTexShape(shapeAs3D);\n\n      if (isPacked) {\n        program = new DecodeMatrixPackedProgram(shapeAs3D);\n      } else {\n        program = new DecodeMatrixProgram(shapeAs3D);\n      }\n\n      var preventEagerUnpackingOfOutput = true;\n      var customValues = [denseTexShape];\n      var out = this.runWebGLProgram(program, [{\n        shape: shapeAs3D,\n        dtype: dtype,\n        dataId: dataId\n      }], dtype, customValues, preventEagerUnpackingOfOutput);\n      return {\n        dtype: dtype,\n        shape: shape,\n        dataId: out.dataId\n      };\n    }\n  }, {\n    key: \"runWebGLProgram\",\n    value: function runWebGLProgram(program, inputs, outputDtype, customUniformValues) {\n      var _this3 = this;\n\n      var preventEagerUnpackingOfOutput = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var output = this.makeTensorInfo(program.outputShape, outputDtype);\n      var outData = this.texData.get(output.dataId);\n\n      if (program.packedOutput) {\n        outData.isPacked = true;\n      }\n\n      if (program.outPackingScheme === tex_util.PackingScheme.DENSE) {\n        var texelShape = tex_util.getDenseTexShape(program.outputShape); // For a densely packed output, we explicitly set texShape\n        // so it doesn't get assigned later according to our typical packing\n        // scheme wherein a single texel can only contain values from adjacent\n        // rows/cols.\n\n        outData.texShape = texelShape.map(function (d) {\n          return d * 2;\n        });\n      }\n\n      if (program.outTexUsage != null) {\n        outData.usage = program.outTexUsage;\n      }\n\n      if (util.sizeFromShape(output.shape) === 0) {\n        // Short-circuit the computation since the result is empty (has 0 in its\n        // shape).\n        outData.values = util.getTypedArrayFromDType(output.dtype, 0);\n        return output;\n      }\n\n      var dataToDispose = [];\n      var inputsData = inputs.map(function (input) {\n        if (input.dtype === 'complex64') {\n          throw new Error(\"GPGPUProgram does not support complex64 input. For complex64 \" + \"dtypes, please separate the program into real and imaginary \" + \"parts.\");\n        }\n\n        var texData = _this3.texData.get(input.dataId);\n\n        if (texData.texture == null) {\n          if (!program.packedInputs && util.sizeFromShape(input.shape) <= env().getNumber('WEBGL_SIZE_UPLOAD_UNIFORM')) {\n            // Upload small tensors that live on the CPU as uniforms, not as\n            // textures. Do this only when the environment supports 32bit floats\n            // due to problems when comparing 16bit floats with 32bit floats.\n            // TODO(https://github.com/tensorflow/tfjs/issues/821): Make it\n            // possible for packed shaders to sample from uniforms.\n            return {\n              shape: input.shape,\n              texData: null,\n              isUniform: true,\n              uniformValues: texData.values\n            };\n          } // This ensures that if a packed program's inputs have not yet been\n          // uploaded to the GPU, they get uploaded as packed right off the bat.\n\n\n          if (program.packedInputs) {\n            texData.isPacked = true;\n            texData.shape = input.shape;\n          }\n        } else if (!!texData.isPacked !== !!program.packedInputs) {\n          input = texData.isPacked ? _this3.unpackTensor(input) : _this3.packTensor(input);\n          dataToDispose.push(input);\n          texData = _this3.texData.get(input.dataId);\n        } else if (texData.isPacked && !webgl_util.isReshapeFree(texData.shape, input.shape)) {\n          // This is a special case where a texture exists for a tensor\n          // but the shapes are incompatible (due to packing constraints) because\n          // the tensor did not have a chance to go through the packed reshape\n          // shader. This only happens when we reshape the *same* tensor to form\n          // *distinct* inputs to an op, e.g. dotting a vector with itself. This\n          // case will disappear once packed uploading is the default.\n          var savedInput = input;\n          var targetShape = input.shape;\n          input.shape = texData.shape;\n          input = _this3.packedReshape(input, targetShape);\n          dataToDispose.push(input);\n          texData = _this3.texData.get(input.dataId);\n          savedInput.shape = targetShape;\n        }\n\n        _this3.uploadToGPU(input.dataId);\n\n        return {\n          shape: input.shape,\n          texData: texData,\n          isUniform: false\n        };\n      });\n      this.uploadToGPU(output.dataId);\n      var outputData = {\n        shape: output.shape,\n        texData: outData,\n        isUniform: false\n      };\n      var key = gpgpu_math.makeShaderKey(program, inputsData, outputData);\n      var binary = this.getAndSaveBinary(key, function () {\n        return gpgpu_math.compileProgram(_this3.gpgpu, program, inputsData, outputData);\n      });\n      var shouldTimeProgram = this.activeTimers != null;\n      var query;\n\n      if (shouldTimeProgram) {\n        query = this.startTimer();\n      }\n\n      gpgpu_math.runProgram(this.gpgpu, binary, inputsData, outputData, customUniformValues);\n      dataToDispose.forEach(function (info) {\n        return _this3.disposeIntermediateTensorInfo(info);\n      });\n\n      if (shouldTimeProgram) {\n        query = this.endTimer(query);\n        this.activeTimers.push({\n          name: program.constructor.name,\n          query: this.getQueryTime(query)\n        });\n      }\n\n      var glFlushThreshold = env().get('WEBGL_FLUSH_THRESHOLD'); // Manually GL flush requested\n\n      if (glFlushThreshold > 0) {\n        var time = util.now();\n\n        if (time - this.lastGlFlushTime > glFlushThreshold) {\n          this.gpgpu.gl.flush();\n          this.lastGlFlushTime = time;\n        }\n      }\n\n      if (!env().getBool('WEBGL_LAZILY_UNPACK') && outData.isPacked && preventEagerUnpackingOfOutput === false) {\n        var unpacked = this.unpackTensor(output);\n        this.disposeIntermediateTensorInfo(output);\n        return unpacked;\n      }\n\n      return output;\n    }\n  }, {\n    key: \"compileAndRun\",\n    value: function compileAndRun(program, inputs, outputDtype, customUniformValues) {\n      var preventEagerUnpackingOfOutput = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      outputDtype = outputDtype || inputs[0].dtype;\n      var outInfo = this.runWebGLProgram(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput);\n      return outInfo;\n    }\n  }, {\n    key: \"getAndSaveBinary\",\n    value: function getAndSaveBinary(key, getBinary) {\n      if (!(key in this.binaryCache)) {\n        this.binaryCache[key] = getBinary();\n      }\n\n      return this.binaryCache[key];\n    }\n  }, {\n    key: \"getTextureManager\",\n    value: function getTextureManager() {\n      return this.textureManager;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _this4 = this;\n\n      if (this.disposed) {\n        return;\n      } // Avoid disposing the compiled webgl programs during unit testing because\n      // it slows down test execution.\n\n\n      if (!env().getBool('IS_TEST')) {\n        var allKeys = Object.keys(this.binaryCache);\n        allKeys.forEach(function (key) {\n          _this4.gpgpu.deleteProgram(_this4.binaryCache[key].webGLProgram);\n\n          delete _this4.binaryCache[key];\n        });\n      }\n\n      this.textureManager.dispose();\n\n      if (this.canvas != null && typeof HTMLCanvasElement !== 'undefined' && this.canvas instanceof HTMLCanvasElement) {\n        this.canvas.remove();\n      } else {\n        this.canvas = null;\n      }\n\n      if (this.gpgpuCreatedLocally) {\n        this.gpgpu.program = null;\n        this.gpgpu.dispose();\n      }\n\n      this.disposed = true;\n    }\n  }, {\n    key: \"floatPrecision\",\n    value: function floatPrecision() {\n      var _this5 = this;\n\n      if (this.floatPrecisionValue == null) {\n        this.floatPrecisionValue = tidy(function () {\n          if (!env().get('WEBGL_RENDER_FLOAT32_ENABLED')) {\n            // Momentarily switching DEBUG flag to false so we don't throw an\n            // error trying to upload a small value.\n            var debugFlag = env().getBool('DEBUG');\n            env().set('DEBUG', false);\n\n            var underflowCheckValue = _this5.abs(scalar(1e-8)).dataSync()[0];\n\n            env().set('DEBUG', debugFlag);\n\n            if (underflowCheckValue > 0) {\n              return 32;\n            }\n          }\n\n          return 16;\n        });\n      }\n\n      return this.floatPrecisionValue;\n    }\n    /** Returns the smallest representable number.  */\n\n  }, {\n    key: \"epsilon\",\n    value: function epsilon() {\n      return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n    }\n  }, {\n    key: \"uploadToGPU\",\n    value: function uploadToGPU(dataId) {\n      var texData = this.texData.get(dataId);\n      var shape = texData.shape,\n          dtype = texData.dtype,\n          values = texData.values,\n          texture = texData.texture,\n          usage = texData.usage,\n          isPacked = texData.isPacked;\n\n      if (texture != null) {\n        // Array is already on GPU. No-op.\n        return;\n      }\n\n      var shouldTimeProgram = this.activeTimers != null;\n      var start;\n\n      if (shouldTimeProgram) {\n        start = util.now();\n      }\n\n      var texShape = texData.texShape;\n\n      if (texShape == null) {\n        texShape = webgl_util.getTextureShapeFromLogicalShape(shape, isPacked);\n        texData.texShape = texShape;\n      }\n\n      if (values != null) {\n        var shapeAs3D = webgl_util.getShapeAs3D(shape);\n        var program;\n        var width = texShape[1],\n            height = texShape[0];\n        var isByteArray = values instanceof Uint8Array;\n\n        if (isPacked) {\n          var _tex_util$getPackedMa = tex_util.getPackedMatrixTextureShapeWidthHeight(texShape[0], texShape[1]);\n\n          var _tex_util$getPackedMa2 = _slicedToArray(_tex_util$getPackedMa, 2);\n\n          width = _tex_util$getPackedMa2[0];\n          height = _tex_util$getPackedMa2[1];\n          program = new EncodeMatrixPackedProgram(shapeAs3D, isByteArray);\n        } else {\n          program = new EncodeMatrixProgram(shapeAs3D, isByteArray);\n        }\n\n        var tempDenseInputHandle = this.makeTensorInfo([height, width], dtype);\n\n        if (isByteArray) {\n          this.texData.get(tempDenseInputHandle.dataId).usage = TextureUsage.PIXELS;\n        } else {\n          this.texData.get(tempDenseInputHandle.dataId).usage = TextureUsage.UPLOAD;\n        }\n\n        this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId), width, height, values);\n        var customValues = [[height, width]]; // We want the output to remain packed regardless of the value of\n        // WEBGL_PACK.\n\n        var preventEagerUnpacking = true;\n        var encodedOutputTarget = this.runWebGLProgram(program, [tempDenseInputHandle], dtype, customValues, preventEagerUnpacking); // Have the original texture assume the identity of the encoded output.\n\n        var outputTexData = this.texData.get(encodedOutputTarget.dataId);\n        texData.texture = outputTexData.texture;\n        texData.texShape = outputTexData.texShape;\n        texData.isPacked = outputTexData.isPacked;\n        texData.usage = outputTexData.usage;\n        this.disposeIntermediateTensorInfo(tempDenseInputHandle);\n        this.texData.delete(encodedOutputTarget.dataId); // Once uploaded, don't store the values on cpu.\n\n        texData.values = null;\n\n        if (shouldTimeProgram) {\n          this.uploadWaitMs += util.now() - start;\n        }\n      } else {\n        var newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);\n        texData.texture = newTexture;\n      }\n    }\n  }, {\n    key: \"convertAndCacheOnCPU\",\n    value: function convertAndCacheOnCPU(dataId, float32Values) {\n      var texData = this.texData.get(dataId);\n      var dtype = texData.dtype;\n      this.releaseGPUData(dataId);\n\n      if (float32Values != null) {\n        texData.values = float32ToTypedArray(float32Values, dtype);\n      }\n\n      return texData.values;\n    }\n  }, {\n    key: \"acquireTexture\",\n    value: function acquireTexture(texShape, texType, dtype, isPacked) {\n      this.numBytesInGPU += this.computeBytes(texShape, dtype);\n\n      if (!this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {\n        var mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);\n        this.warnedAboutMemory = true;\n        console.warn(\"High memory usage in GPU: \".concat(mb, \" MB, \") + \"most likely due to a memory leak\");\n      }\n\n      return this.textureManager.acquireTexture(texShape, texType, isPacked);\n    }\n  }, {\n    key: \"computeBytes\",\n    value: function computeBytes(shape, dtype) {\n      return shape[0] * shape[1] * util.bytesPerElement(dtype);\n    }\n  }]);\n\n  return MathBackendWebGL;\n}(KernelBackend);\nMathBackendWebGL.nextDataId = 0;\n\nfunction float32ToTypedArray(a, dtype) {\n  if (dtype === 'float32' || dtype === 'complex64') {\n    return a;\n  } else if (dtype === 'int32' || dtype === 'bool') {\n    var result = dtype === 'int32' ? new Int32Array(a.length) : new Uint8Array(a.length);\n\n    for (var i = 0; i < result.length; ++i) {\n      result[i] = Math.round(a[i]);\n    }\n\n    return result;\n  } else {\n    throw new Error(\"Unknown dtype \".concat(dtype));\n  }\n}","map":null,"metadata":{},"sourceType":"module"}