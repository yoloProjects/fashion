{"ast":null,"code":"import _slicedToArray from \"C:\\\\PythonProjects\\\\Fashion\\\\YOLOTFjf\\\\tfjs-yolov5-example\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { SparseFillEmptyRows } from '@tensorflow/tfjs-core';\nimport { sparseFillEmptyRowsImpl } from './SparseFillEmptyRows_impl';\nexport function sparseFillEmptyRows(args) {\n  var inputs = args.inputs,\n      backend = args.backend;\n  var indices = inputs.indices,\n      values = inputs.values,\n      denseShape = inputs.denseShape,\n      defaultValue = inputs.defaultValue;\n\n  if (denseShape.shape.length !== 1) {\n    throw new Error(\"Dense shape must be a vector, saw:\\n        \".concat(denseShape.shape));\n  }\n\n  if (indices.shape.length !== 2) {\n    throw new Error(\"Indices must be a matrix, saw:\\n        \".concat(indices.shape));\n  }\n\n  if (values.shape.length !== 1) {\n    throw new Error(\"Values must be a vector, saw:\\n        \".concat(values.shape));\n  }\n\n  if (defaultValue.shape.length !== 0) {\n    throw new Error(\"Default value must be a scalar, saw:\\n        \".concat(defaultValue.shape));\n  }\n\n  var $indices = backend.data.get(indices.dataId).values;\n  var $values = backend.data.get(values.dataId).values;\n  var $denseShape = backend.data.get(denseShape.dataId).values;\n  var $defaultValue = backend.data.get(defaultValue.dataId).values[0];\n\n  var _sparseFillEmptyRowsI = sparseFillEmptyRowsImpl($indices, indices.shape, indices.dtype, $values, values.dtype, $denseShape, $defaultValue),\n      _sparseFillEmptyRowsI2 = _slicedToArray(_sparseFillEmptyRowsI, 5),\n      outputIndices = _sparseFillEmptyRowsI2[0],\n      outputIndicesShape = _sparseFillEmptyRowsI2[1],\n      outputValues = _sparseFillEmptyRowsI2[2],\n      emptyRowIndicator = _sparseFillEmptyRowsI2[3],\n      reverseIndexMap = _sparseFillEmptyRowsI2[4];\n\n  return [backend.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices), backend.makeTensorInfo([outputIndicesShape[0]], values.dtype, outputValues), backend.makeTensorInfo([emptyRowIndicator.length], 'bool', new Uint8Array(emptyRowIndicator.map(function (value) {\n    return Number(value);\n  }))), backend.makeTensorInfo([reverseIndexMap.length], indices.dtype, new Int32Array(reverseIndexMap))];\n}\nexport var sparseFillEmptyRowsConfig = {\n  kernelName: SparseFillEmptyRows,\n  backendName: 'cpu',\n  kernelFunc: sparseFillEmptyRows\n};","map":null,"metadata":{},"sourceType":"module"}